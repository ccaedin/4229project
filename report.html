<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Copy Detection Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-uWxY/CJNBR+1zjPWmfnSnVxwRheevXITnMqoEIeG1LJrdI0GlVs/9cVSyPYXdcSF" crossorigin="anonymous">

  <style>
    h1 {
      text-align: center;
    }
    .highlight-green {
      background-color: #b6f2b6;
    }
    .highlight-red {
      background-color: #f2b6b6;
    }
    pre {
      text-align: left;
    }
    .col3 {
      float: left;
      width: 33%;
    }
    .file-info-list {
      max-height: 900px;
      overflow-y: scroll;
    }
    .main-report-div {
      margin-top: 3em;
      max-width: 1400px;
    }
    .code-display {
      max-width: 600px
    }
  </style></head>
<body>
<div class="container main-report-div">
  <h1 style="margin-bottom: 1em;">Copy Detection Report</h1>
  <h2>Overview</h2>
    <div class="container d-flex justify-content-center">
      <div class="col">
        <h4 style="text-align: center;">Similarity Matrix</h4>
        <img src="data:image/png;base64, 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" alt="Code similarity matrix">
      </div>
      <div class="col">
        <h4 style="text-align: center;">Similarity Score Distribution</h4>
        <img src="data:image/png;base64, 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e0fqvn/3dNfz6S53LHu7W67z62ezu+U66Lxr6c9Q2zUsy+rU43tNAH755ZdqaWmR2+2O2O92u3X8+PHL1hcXF+vZZ5+9bH96enqXzQgA7XGt6ekJYutaez7dhb9vaNOd/yycPXtWLperw4/rNQHYUUVFRZo/f779c2trq86cOaPBgwcrLi6uy64bCoWUnp6u2tpaOZ3OLrsOegfutzm412bhfpvjWr3XlmXp7NmzSktL69Tje00AXn/99UpISFAgEIjYHwgE5PF4LlvvcDjkcDgi9iUnJ3fliBGcTuc19Q8Sfjfutzm412bhfpvjWrzXnXnlr02v+RqYpKQkjR07VhUVFfa+1tZWVVRUyOv19uBkAAAA15Ze8wqgJM2fP1/5+fkaN26c7rrrLq1Zs0bnz5+3PxUMAACA6PWqAHzsscd0+vRpLV26VH6/X3feead279592QdDepLD4dCyZcsu+/Uzrk3cb3Nwr83C/TYH97p9cVZnPz8MAACAq1KveQ8gAAAAugcBCAAAYBgCEAAAwDAEIAAAgGEIwHasW7dOw4cPV9++fZWZmakPP/zwd67fsWOHRo4cqb59+2r06NF66623umlSxEJH7vcrr7yie++9V9ddd52uu+46ZWVlXfGfD/QeHf2z3Wb79u2Ki4vTlClTunZAxFRH73dDQ4MKCgo0dOhQORwO3Xrrrfz7/CrR0Xu9Zs0a3XbbberXr5/S09M1b948XbhwoZum7SUsRNi+fbuVlJRk/eIXv7COHDlizZw500pOTrYCgUC76z/44AMrISHBKikpsY4ePWotXrzY6tOnj3X48OFunhyd0dH7/YMf/MBat26d9atf/co6duyY9fjjj1sul8v64osvunlydFRH73WbkydPWr/3e79n3XvvvdbDDz/cPcMiah293+Fw2Bo3bpw1efJk6/3337dOnjxpvfvuu9ahQ4e6eXJ0VEfv9datWy2Hw2Ft3brVOnnypPX2229bQ4cOtebNm9fNk/csAvASd911l1VQUGD/3NLSYqWlpVnFxcXtrn/00UetnJyciH2ZmZnWj3/84y6dE7HR0ft9qebmZmvQoEHWli1bumpExEhn7nVzc7N19913W//wD/9g5efnE4BXkY7e7w0bNlg33XST1djY2F0jIkY6eq8LCgqs++67L2Lf/PnzrQkTJnTpnL0NvwK+SGNjo6qqqpSVlWXvi4+PV1ZWlnw+X7uP8fl8EeslKTs7+2vXo/fozP2+1FdffaWmpialpKR01ZiIgc7e6+XLlys1NVUzZszojjERI52537/85S/l9XpVUFAgt9utO+64QytXrlRLS0t3jY1O6My9vvvuu1VVVWX/mvizzz7TW2+9pcmTJ3fLzL1Fr/ovgfS0L7/8Ui0tLZf9l0fcbreOHz/e7mP8fn+76/1+f5fNidjozP2+1MKFC5WWlnbZ/wlA79KZe/3+++9r48aNOnToUDdMiFjqzP3+7LPPtHfvXuXl5emtt97Sp59+qieffFJNTU1atmxZd4yNTujMvf7BD36gL7/8Uvfcc48sy1Jzc7N+8pOf6K/+6q+6Y+Reg1cAgU5atWqVtm/frtdff119+/bt6XEQQ2fPntX06dP1yiuv6Prrr+/pcdANWltblZqaqpdfflljx47VY489pp/97GcqLS3t6dEQY++++65Wrlyp9evX6+OPP9a//uu/aufOnVqxYkVPj9ateAXwItdff70SEhIUCAQi9gcCAXk8nnYf4/F4OrQevUdn7nebF154QatWrdKePXs0ZsyYrhwTMdDRe/2b3/xGn3/+uR566CF7X2trqyQpMTFR1dXVuvnmm7t2aHRaZ/5sDx06VH369FFCQoK9b9SoUfL7/WpsbFRSUlKXzozO6cy9XrJkiaZPn64f/ehHkqTRo0fr/PnzmjVrln72s58pPt6M18bMeJbfUFJSksaOHauKigp7X2trqyoqKuT1ett9jNfrjVgvSeXl5V+7Hr1HZ+63JJWUlGjFihXavXu3xo0b1x2jIkodvdcjR47U4cOHdejQIXv70z/9U333u9/VoUOHlJ6e3p3jo4M682d7woQJ+vTTT+3Ql6RPPvlEQ4cOJf56sc7c66+++uqyyGsLf8uyum7Y3qanP4XS22zfvt1yOBzW5s2braNHj1qzZs2ykpOTLb/fb1mWZU2fPt1atGiRvf6DDz6wEhMTrRdeeME6duyYtWzZMr4G5irS0fu9atUqKykpyfqXf/kX69SpU/Z29uzZnnoK+IY6eq8vxaeAry4dvd81NTXWoEGDrMLCQqu6utoqKyuzUlNTreeee66nngK+oY7e62XLllmDBg2y/umf/sn67LPPrHfeece6+eabrUcffbSnnkKPIADb8dJLL1nDhg2zkpKSrLvuuss6cOCAfeyP/uiPrPz8/Ij1r732mnXrrbdaSUlJ1u23327t3LmzmydGNDpyv2+88UZL0mXbsmXLun9wdFhH/2xfjAC8+nT0fu/fv9/KzMy0HA6HddNNN1nPP/+81dzc3M1TozM6cq+bmpqsZ555xrr55putvn37Wunp6daTTz5p/fa3v+3+wXtQnGWZ9HonAAAAeA8gAACAYQhAAAAAwxCAAAAAhiEAAQAADEMAAgAAGIYABAAAMAwBCAAAYBgCEAAAwDAEIAAAgGEIQAAAAMMQgAAAAIYhAAEAAAxDAAIAABiGAAQAADAMAQgAAGAYAhAAAMAwBCAAAIBh/h868K3mFMfLNAAAAABJRU5ErkJggg==" alt="Code similarity histogram">
      </div>
    </div>
    <p style="text-align: center">
      <i>Note: a score of -1 in the similarity matrix indicates the comparison was skipped</i>
    </p>

    <div class="row" style="font-size: small;">
      <div class="col3">
        <p>
          <b>Number of files tested (vertical):</b> 31<br>
          <b>Number above display threshold:</b> 13 (41.94%)<br><br>
          <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-test-files" aria-expanded="false" aria-controls="collapse-test-files">
            View <i>test</i> files
          </button>
        </p>
        <div class="collapse" id="collapse-test-files">
          <ul class="file-info-list">
              <li>0=Texture.h</li> 
            
              <li>1=objects/Human.h</li> 
            
              <li>2=Text.h</li> 
            
              <li>3=objects/Object.h</li> 
            
              <li>4=Mesh.cpp</li> 
            
              <li>5=shapes.cpp</li> 
            
              <li>6=objects/Cylinder.cpp</li> 
            
              <li>7=lib.h</li> 
            
              <li>8=objects/Cylinder.h</li> 
            
              <li>9=Particles.cpp</li> 
            
              <li>10=Particles.h</li> 
            
              <li>11=Mesh.h</li> 
            
              <li>12=objects/Sphere.h</li> 
            
              <li>13=objects/Skybox.h</li> 
            
              <li>14=Camera.h</li> 
            
              <li>15=objects/House.cpp</li> 
            
              <li>16=Shader.cpp</li> 
            
              <li>17=Camera.cpp</li> 
            
              <li>18=Texture.cpp</li> 
            
              <li>19=objects/Tree.h</li> 
            
              <li>20=Shader.h</li> 
            
              <li>21=objects/Sphere.cpp</li> 
            
              <li>22=Text.cpp</li> 
            
              <li>23=objects/Cube.cpp</li> 
            
              <li>24=shapes.h</li> 
            
              <li>25=objects/House.h</li> 
            
              <li>26=objects/Cube.h</li> 
            
              <li>27=army.cpp</li> 
            
              <li>28=objects/Human.cpp</li> 
            
              <li>29=objects/Skybox.cpp</li> 
            
              <li>30=objects/Tree.cpp</li> 
            </ul>
        </div>
      </div>
      <div class="col3">
        <p>
          <b>Number of reference files (horizontal):</b> 31<br><br><br>
          <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-reference-files" aria-expanded="false" aria-controls="collapse-reference-files">
            View <i>reference</i> files
          </button>
        </p>
        <div class="collapse" id="collapse-reference-files">
          <ul class="file-info-list">
              <li>0=Texture.h</li> 
            
              <li>1=objects/Human.h</li> 
            
              <li>2=Text.h</li> 
            
              <li>3=objects/Object.h</li> 
            
              <li>4=Mesh.cpp</li> 
            
              <li>5=shapes.cpp</li> 
            
              <li>6=objects/Cylinder.cpp</li> 
            
              <li>7=lib.h</li> 
            
              <li>8=objects/Cylinder.h</li> 
            
              <li>9=Particles.cpp</li> 
            
              <li>10=Particles.h</li> 
            
              <li>11=Mesh.h</li> 
            
              <li>12=objects/Sphere.h</li> 
            
              <li>13=objects/Skybox.h</li> 
            
              <li>14=Camera.h</li> 
            
              <li>15=objects/House.cpp</li> 
            
              <li>16=Shader.cpp</li> 
            
              <li>17=Camera.cpp</li> 
            
              <li>18=Texture.cpp</li> 
            
              <li>19=objects/Tree.h</li> 
            
              <li>20=Shader.h</li> 
            
              <li>21=objects/Sphere.cpp</li> 
            
              <li>22=Text.cpp</li> 
            
              <li>23=objects/Cube.cpp</li> 
            
              <li>24=shapes.h</li> 
            
              <li>25=objects/House.h</li> 
            
              <li>26=objects/Cube.h</li> 
            
              <li>27=army.cpp</li> 
            
              <li>28=objects/Human.cpp</li> 
            
              <li>29=objects/Skybox.cpp</li> 
            
              <li>30=objects/Tree.cpp</li> 
            </ul>
        </div>
      </div>
      <div class="col3">
        <p>
          <b>Execution params (see <code>copydetect --help</code>):</b><br><br><br>
          <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-exec-params" aria-expanded="false" aria-controls="collapse-exec-params">
            View execution parameters
          </button>
        </p>
        <div class="collapse" id="collapse-exec-params">
          <b>version:</b> 0.5.0<br>
          <b>Configuration:</b>
          <pre class="file-info-list">{
    "extensions": [
        "cc",
        "cpp",
        "h"
    ],
    "same_name_only": false,
    "ignore_leaf": false,
    "disable_filtering": false,
    "truncate": false,
    "out_file": "./report.html",
    "css_files": [],
    "silent": false,
    "encoding": "utf-8",
    "window_size": 1,
    "noise_threshold": 25,
    "guarantee_threshold": 25,
    "display_threshold": 0.33,
    "test_directories": [
        "."
    ],
    "reference_directories": [
        "."
    ],
    "boilerplate_directories": [],
    "disable_autoopen": false
}</pre>
        </div>
      </div>
    </div>


  <h2>Matched Code</h2>
  <table class="table table-striped table-sm">
  <tbody class="table-light">
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>lib.h</i> (<b>84.44%</b>)<br>
    Reference file: <i>shapes.h</i> (<b>16.76%</b>)<br>
    Token overlap: 76<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-1" aria-expanded="false" aria-controls="collapse-1">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-1">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>#ifndef LIB_H
#define LIB_H

#pragma once
#define GL_GLEXT_PROTOTYPES

#ifdef __APPLE__
#include &lt;GLUT/glut.h&gt;
#include &lt;SDL.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;SDL_opengl.h&gt;
// Tell Xcode IDE to not gripe about OpenGL deprecation
#pragma clang diagnostic ignored &#34;-Wdeprecated-declarations&#34;
#else
#include &lt;GL/glew.h&gt;
// #include &lt;GL/glut.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_ttf.h&gt;
// #include &lt;GL/gl.h&gt;
// #include &lt;GL/glu.h&gt;
#endif

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;vector&gt;

#define PI 3.14159265359

#define Cos(x) (cos((x) * 3.14159265 / 180))
#define Sin(x) (sin((x) * 3.14159265 / 180))

</span>extern bool show_normals; // show normals

#endif // LIB_H

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>#ifndef SHAPES_H
#define SHAPES_H

#pragma once
#include &#34;lib.h&#34;
#include &#34;Texture.h&#34;
#include &#34;Mesh.h&#34;
#include &#34;objects/Cylinder.h&#34;
#include &#34;objects/Sphere.h&#34;
#include &#34;objects/Cube.h&#34;
#include &#34;Shader.h&#34;


</span>void Vertex(double th, double ph);
Mesh* cylinder(float len, float wid, Texture *texure, Shader* shader);
// Mesh* sphere(glm::vec3 pos, float r, Texture *texture);
// Mesh* tree(glm::vec3 pos, glm::vec3 rot, Texture *bark, Texture *leaves);
// Mesh* human(glm::vec3 pos, glm::vec3 rot, int arm_seperation, int leg_seperation, Texture *body_texture, Texture *head_texture);
Mesh* cube(glm::vec3 pos, glm::vec3 rot, Texture *texture[], float reps, Shader* shader);
std::vector&lt;Mesh*&gt; house(glm::vec3 pos, glm::vec3 rot,  Texture* house_text[], float house_reps, Texture* roof_text[], Texture* fire, Shader* shader, std::vector&lt;glm::vec3&gt; &amp;lightPositions);
// Mesh* sun(glm::vec3 pos, glm::vec3 rot, float shiny, int emission, Texture *texture);
// Mesh* moon(glm::vec3 pos, glm::vec3 rot, float shiny, int emission, Texture *texture);

#endif // SHAPES_H
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>lib.h</i> (<b>84.44%</b>)<br>
    Reference file: <i>objects/House.h</i> (<b>13.85%</b>)<br>
    Token overlap: 76<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-2" aria-expanded="false" aria-controls="collapse-2">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-2">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>#ifndef LIB_H
#define LIB_H

#pragma once
#define GL_GLEXT_PROTOTYPES

#ifdef __APPLE__
#include &lt;GLUT/glut.h&gt;
#include &lt;SDL.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;SDL_opengl.h&gt;
// Tell Xcode IDE to not gripe about OpenGL deprecation
#pragma clang diagnostic ignored &#34;-Wdeprecated-declarations&#34;
#else
#include &lt;GL/glew.h&gt;
// #include &lt;GL/glut.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_ttf.h&gt;
// #include &lt;GL/gl.h&gt;
// #include &lt;GL/glu.h&gt;
#endif

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;vector&gt;

#define PI 3.14159265359

#define Cos(x) (cos((x) * 3.14159265 / 180))
#define Sin(x) (sin((x) * 3.14159265 / 180))

</span>extern bool show_normals; // show normals

#endif // LIB_H

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>#ifndef HOUSE_H
#define HOUSE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;
#include &#34;Cube.h&#34;
#include &#34;Cylinder.h&#34;
#include &#34;Sphere.h&#34;
#include &#34;../Mesh.h&#34;
#include &#34;../Particles.h&#34;

</span>class House : public Cube
{
public:
    House(glm::vec3 pos, glm::vec3 scale, glm::vec3 rot, TextureGroup* brickTexture, TextureGroup* roofTexture, TextureGroup *torchTexture, TextureGroup* fireTexture, Shader* shader, Shader* smokeShader, Camera* camera);
    void draw(float deltaTime);
    std::vector&lt;glm::vec3&gt; getLights() { return lightPositions; }

private:

    Texture *brickColor;
    Texture *brickNormal;

    Texture *roofColor;
    Texture *roofNormal;

    Texture* torchColor;
    Texture* torchNormal;

    Cylinder* torch1;
    Sphere* torch1Fire;
    Particles* torch1Smoke;
    
    Cylinder* torch2;
    Sphere* torch2Fire;
    Particles* torch2Smoke;

    Mesh* roof;

    std::vector&lt;glm::vec3&gt; lightPositions;

    Camera* camera;

};
#endif // HOUSE_H</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>lib.h</i> (<b>84.44%</b>)<br>
    Reference file: <i>army.cpp</i> (<b>0.80%</b>)<br>
    Token overlap: 76<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-3" aria-expanded="false" aria-controls="collapse-3">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-3">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>#ifndef LIB_H
#define LIB_H

#pragma once
#define GL_GLEXT_PROTOTYPES

#ifdef __APPLE__
#include &lt;GLUT/glut.h&gt;
#include &lt;SDL.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;SDL_opengl.h&gt;
// Tell Xcode IDE to not gripe about OpenGL deprecation
#pragma clang diagnostic ignored &#34;-Wdeprecated-declarations&#34;
#else
#include &lt;GL/glew.h&gt;
// #include &lt;GL/glut.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_ttf.h&gt;
// #include &lt;GL/gl.h&gt;
// #include &lt;GL/glu.h&gt;
#endif

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include &lt;vector&gt;

#define PI 3.14159265359

#define Cos(x) (cos((x) * 3.14159265 / 180))
#define Sin(x) (sin((x) * 3.14159265 / 180))

</span>extern bool show_normals; // show normals

#endif // LIB_H

</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>//todo: day night
//todo: why is grass so green?
//todo: fix abbrupt change in color and lighting
<span class='highlight-green'>#include &#34;lib.h&#34;
#include &#34;Text.h&#34;
#include &#34;Camera.h&#34;
#include &#34;Texture.h&#34;
#include &lt;vector&gt;
#include &#34;Shader.h&#34;
// #include &#34;Mesh.h&#34;
#include &#34;Particles.h&#34;
#include &#34;shapes.h&#34;
#include &#34;objects/Cylinder.h&#34;
#include &#34;objects/Sphere.h&#34;
#include &#34;objects/Skybox.h&#34;
#include &#34;objects/House.h&#34;
#include &#34;objects/Tree.h&#34;
#include &#34;objects/Human.h&#34;

// settings
</span>static void draw_screen(float deltaTime);
void handle_key_event(SDL_Event event);
void gl_error();
void resize(int width, int height);

int ph = 20;
int th = -90;
int w_width = 800;
int w_height = 600;
float aspect = (float)w_width / (float)w_height;
bool is_fullscreen = false;
SDL_Window *Window;
SDL_GLContext Context;
// Text arial = Text(&#34;arial.ttf&#34;, 24);
bool quit = false;

int leg_angle = 90;
bool leg_angle_backwards = false;
int arm_angle = 180;
bool arm_angle_backwards = false;

float march = 0.01;
int number_rows = 5;
int number_groups = 1;
bool show_commands = false;
int mode = 0;
bool lighting = true;
bool smooth = true;
bool local_viewer = true;
bool show_normals = false;

int ambient = 0;
int diffuse = 80;
int specular = 0;

int shine =  1;
int emission = 5;

bool stop_army = false;
bool stop_sun = false;

bool grab_mouse = false;


int sun_width = 7;

int fov = 57;
int dim = 10;
enum projection_types
{
    ORTHOGONAL,
    PERSPECTIVE,
    FIRST_PERSON,
    THIRD_PERSON
};
int projection = FIRST_PERSON;
std::string projection_names[] = {&#34;Orthogonal&#34;, &#34;Perspective&#34;, &#34;First Person&#34;, &#34;Third Person&#34;};

// glm vertex camera position
Camera camera = Camera();
Camera camera3 = Camera();

bool solider_pov = false;
int solider = 0;

static void Projection()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (projection == PERSPECTIVE || projection == FIRST_PERSON || projection == THIRD_PERSON)
    {
        camera.SetProjectionMatrix(fov, dim, aspect);
    }
    else if (projection == ORTHOGONAL)
        glOrtho(-dim * aspect, dim * aspect, -dim * sqrt(2), dim * sqrt(2), -dim - sqrt(2), dim + sqrt(2));
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    if (projection == FIRST_PERSON &amp;&amp; grab_mouse)
    {
        // capture the mouse inside the window
        SDL_SetWindowGrab(Window, SDL_TRUE);
        // rotate the camera
        SDL_ShowCursor(SDL_DISABLE);
    }
    else
    {
        SDL_SetWindowGrab(Window, SDL_FALSE);
        SDL_ShowCursor(SDL_ENABLE);
    }
}


Shader *shader = nullptr;
Shader *particleShader = nullptr;
int floor_div = 1;
bool texture = true;
Texture *grass = nullptr;
Texture *grass_normal = nullptr;
Texture *brick = nullptr;
Texture *brick_normal = nullptr;

Texture *roof = nullptr;
Texture *roof_normal = nullptr;

Texture *fire_texture = nullptr;
void cleanup()
{


    // SDL_GL_DeleteContext(Context);
    SDL_DestroyWindow(Window);
    SDL_Quit();

    //free the textures
}
// std::vector&lt;glm::vec3&gt; lightPositions;
std::vector&lt;Mesh*&gt; houseMesh;
Mesh *plane = nullptr;
std::vector&lt;House*&gt; houses(10);
std::vector&lt;Tree*&gt; trees;
struct Solider
{
    Human* human;
};
struct Army
{
    std::vector&lt;Human*&gt; soliders;
    glm::vec3 offset;
    int arm_angle = 180;
    int leg_angle = 90;
};
Army army;
bool army_changed = true;
Cylinder* cylinderMesh = nullptr;
Sphere* sphereMesh = nullptr;
Skybox* skybox = nullptr;
float lightPower = 1.0;


int main(int argc, char *argv[])
{
    // glfw: initialize and configure
    // ------------------------------
    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)
    {
        fprintf(stderr, &#34;Error: %s\n&#34;, SDL_GetError());
        return -1;
    }
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    //set compatibility profile
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY);

    // Turn on double buffering with a 24bit Z buffer
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);

    Window = SDL_CreateWindow(&#34;Textures - Caedin Cook&#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, w_width, w_height, SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL | (is_fullscreen * SDL_WINDOW_FULLSCREEN));
    if (Window == NULL)
    {
        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, &#34;Failed to create OpenGL window: %s\n&#34;, SDL_GetError());
        SDL_Quit();
        return 1;
    }

    // Create a OpenGL Context
    Context = SDL_GL_CreateContext(Window);
    if (Context == NULL)
    {
        SDL_LogCritical(SDL_LOG_CATEGORY_APPLICATION, &#34;Failed to create OpenGL context: %s\n&#34;, SDL_GetError());
        SDL_DestroyWindow(Window);
        SDL_Quit();
        return 1;
    }


    //init GLEW
    glewExperimental = GL_TRUE;
    int init_res = glewInit();
    if (init_res != GLEW_OK)
    {
        fprintf(stderr, &#34;Error: %s\n&#34;, glewGetErrorString(init_res));
        return -1;
    }

   
        std::vector&lt;glm::vec3&gt; plane_vertices = {
        glm::vec3(1, 0, 1),
        glm::vec3(-1, 0, -1),
        glm::vec3(-1, 0, 1),
        glm::vec3(1, 0, 1),
        glm::vec3(1, 0, -1),
        glm::vec3(-1, 0, -1),
    };
    float plane_rep = 10;
    std::vector&lt;glm::vec2&gt; plane_uvs = {
        glm::vec2(plane_rep, 0),
        glm::vec2(0, plane_rep),
        glm::vec2(0, 0),
        glm::vec2(plane_rep, 0),
        glm::vec2(plane_rep, plane_rep),
        glm::vec2(0, plane_rep),
    };
    std::vector&lt;glm::vec3&gt; plane_normals = {
        glm::vec3(0, 1, 0),
        glm::vec3(0, 1, 0),
        glm::vec3(0, 1, 0),
        glm::vec3(0, 1, 0),
        glm::vec3(0, 1, 0),
        glm::vec3(0, 1, 0),
    };

    skybox = new Skybox(&amp;camera);

    plane = new Mesh(plane_vertices, plane_uvs, plane_normals);

    grass = new Texture(&#34;./textures/grass/color.png&#34;);
    grass_normal = new Texture(&#34;./textures/grass/normal.png&#34;);

    // glEnable(GL_TEXTURE_2D);
    //initlaize Textures
    brick = new Texture(&#34;./textures/brick/color.jpg&#34;);
    brick_normal = new Texture(&#34;./textures/brick/normal.png&#34;);

    roof = new Texture(&#34;./textures/roof/color.jpg&#34;);
    roof_normal = new Texture(&#34;./textures/roof/normal.png&#34;);

    fire_texture = new Texture(&#34;./textures/fire/color.jpg&#34;);
    shader = new Shader(&#34;./shaders/basic.vert&#34;, &#34;./shaders/basic.frag&#34;);
    if(shader-&gt;getError() != 0)
    {
        SDL_Log(&#34;Error: %d\n&#34;, shader-&gt;getError());
        return 1;
    }
    Texture *brick_textures[] = {brick, brick_normal};
    Texture *roof_textures[] = {roof, roof_normal};
    TextureGroup* brick_texture_group = new TextureGroup(brick_textures[0], brick_textures[1]);
    TextureGroup* roof_texture_group = new TextureGroup(roof_textures[0], roof_textures[1]);
    TextureGroup* fire_texture_group = new TextureGroup(fire_texture, fire_texture);
    TextureGroup *body_texture = new TextureGroup(std::vector&lt;std::string&gt;{&#34;./textures/fabric/color.jpg&#34;, &#34;./textures/fabric/normal.png&#34;});
    TextureGroup* torch_texture_group = new TextureGroup(std::vector&lt;std::string&gt;{&#34;./textures/wood/color.jpg&#34;, &#34;./textures/wood/normal.png&#34;});

    particleShader = new Shader(&#34;./shaders/particle.vert&#34;, &#34;./shaders/particle.frag&#34;);
    int index = 0;
    for (int i = -10; i &lt; 10; i += 4)
    {

        houses[index++] = new House(glm::vec3(-6, 0.0, i + 1), glm::vec3(1,1,1), glm::vec3(0, 0, 0), brick_texture_group, roof_texture_group, torch_texture_group, fire_texture_group, shader, particleShader, &amp;camera);
        houses[index++] = new House(glm::vec3(6, 0.0, i + 1), glm::vec3(1,1,1), glm::vec3(0, 180, 0), brick_texture_group, roof_texture_group, torch_texture_group, fire_texture_group, shader, particleShader, &amp;camera);
    }

    army_changed = false;
    army.soliders.clear();

    // setup army
    for (int g = 0; g &lt; number_groups; g++)
    {
        for (int i = 0; i &lt; number_rows; i++)
        {
            for (int j = 0; j &lt; number_rows - i; j++)
            {

                float group_offset = (number_groups - 1) * (number_rows + 1) / 2.0;
                Human* human = new Human(glm::vec3((j - (number_rows - i) / 2.0), -0.5, i - 2 + g * (number_rows + 1) - group_offset - 10), glm::vec3(0, 0,0), 1, 1, body_texture, brick_texture_group, shader);

                army.soliders.push_back(human);
                
            }
        }
    }


    // lightPositions = lightPositionsTemp;
    //check how many duploicate lights we have

    plane-&gt;setShader(shader);
    plane-&gt;setColorTexture(grass);
    plane-&gt;setNormalTexture(grass_normal);
    plane-&gt;translate(glm::vec3(0, -1, 0));
    plane-&gt;scale(glm::vec3(10, 1, 10));


    TextureGroup* wood_texture_group = new TextureGroup(std::vector&lt;std::string&gt;{&#34;./textures/wood/color.jpg&#34;, &#34;./textures/wood/normal.png&#34;});
    TextureGroup* leaves_texture_group = new TextureGroup(std::vector&lt;std::string&gt;{&#34;./textures/leaves/color.jpg&#34;, &#34;./textures/leaves/normal.png&#34;});
    //setup the trees
    for(int i = -10; i &lt; 10; i+=4)
    {
        trees.push_back(new Tree(glm::vec3(-9.5, 0.0, i + 1), 1, 0.1, wood_texture_group, leaves_texture_group, shader));
        trees.push_back(new Tree(glm::vec3(9.5, 0.0, i + 1), 1, 0.1, wood_texture_group, leaves_texture_group, shader));
    }
    cylinderMesh = new Cylinder(.5, 0.03);
    cylinderMesh-&gt;setShader(shader);
    cylinderMesh-&gt;setColorTexture(brick);
    cylinderMesh-&gt;setNormalTexture(brick_normal);
    cylinderMesh-&gt;translate(glm::vec3(0, 0, 0));

    sphereMesh = new Sphere(0.5, 10, 10);
    sphereMesh-&gt;setShader(shader);
    sphereMesh-&gt;setColorTexture(brick);
    sphereMesh-&gt;setNormalTexture(brick_normal);
    sphereMesh-&gt;translate(glm::vec3(0, 1, 0));


    // ennable depth testing
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    // initialize lorenz and fps counter
    unsigned int lastFrame = SDL_GetTicks();
    unsigned int fpsLast = SDL_GetTicks();
    unsigned int fpsCurrent = 0;
    unsigned int fpsCounter = 0;
    float deltaTime = 0.0f;
    resize(w_width, w_height); // initialize the viewport
    camera.SetPosition(glm::vec3(5, 0, 5));
    camera.LookAt(glm::vec3(0,0,0));
    camera.Look();
    camera.SetAngle(45+905 , 0);
    while (!quit)
    {

        SDL_Event event;
        while (SDL_PollEvent(&amp;event))
        {
            switch (event.type)
            {
            case SDL_QUIT:
                quit = true;
                break;
            case SDL_WINDOWEVENT:
                if (event.window.event == SDL_WINDOWEVENT_RESIZED)
                {
                    w_width = event.window.data1;
                    w_height = event.window.data2;
                    // resize the viewport
                    resize(event.window.data1, event.window.data2);
                }
                break;
            default:
                handle_key_event(event);
                break;
            }
        }
        // delta time in seconds
        // float secs = deltaTime / 1000.0f;
        //  camera.SetSpeed(camera.GetSpeed() * secs);
        draw_screen(deltaTime/1000);
        // get error
        gl_error();
        fpsCounter++;

        if (SDL_GetTicks() - fpsLast &gt;= 1000)
        {
            fpsCurrent = fpsCounter;
            fpsCounter = 0;
            fpsLast = SDL_GetTicks();
            std::string title = &#34;Army Perspective - Caedin Cook FPS: &#34; + std::to_string(fpsCurrent);
            SDL_SetWindowTitle(Window, title.c_str());
            SDL_Log(&#34;FPS: %d\n&#34;, fpsCurrent);
        }
        deltaTime = SDL_GetTicks() - lastFrame;
        lastFrame = SDL_GetTicks();
        SDL_GL_SwapWindow(Window);
    }
    // sdl: terminate, clearing all previously allocated sdl resources.
    // ------------------------------------------------------------------
    cleanup();

    return 0;
}


float time_day = 0;
float time_speed = 0.1;
float accumulated_time = 0;
bool flashLightEnabled = true;
float flickerAlpha = 0.01;
float lastFlicker = 0;
float getFlicker() {
    return (rand() % 100 / 50.0) * flickerAlpha + (1 - flickerAlpha)*lastFlicker;
}
float flicker = getFlicker();
static void draw_screen(float deltaTime)
{
    accumulated_time += deltaTime;
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    if(lighting)
    {
        // }
        glClearColor(0.53, 0.81, 0.98, 1);
        lightPower = 1.0;
        // glm::vec4 Position(distance * Cos(time_day), distance * Sin(time_day), 0, 1);
     }
    else
    {
        glClearColor(0,0,0, 1);
        lightPower = 1;
    }
    glm::mat4 view = camera.GetViewMatrix();
    glm::mat4 projection = camera.GetProjectionMatrix();
    // glm::mat4 mvp = projection * view * model;
    glColor3f(1, 1, 1);

    shader-&gt;use();
    //set the uniforms
    shader-&gt;setMat4(&#34;projection&#34;, projection);
    shader-&gt;setMat4(&#34;view&#34;, view);
    int numLights = 20;
    shader-&gt;setInt(&#34;numLights&#34;, numLights);
    // lightPositions[0] = camera.GetPosition();
    //set light power randomly so it appears to flicker

    //get light positions
    std::vector&lt;glm::vec3&gt; lightPositions;
    for(auto house : houses)
    {
        auto houseLightPositions = house-&gt;getLights();
        for(size_t i = 0; i&lt;houseLightPositions.size(); i++)
        {
            lightPositions.push_back(houseLightPositions[i]);
        }
    }



    for(int i = 0; i&lt;numLights; i++){
        std::string lightName = &#34;lights[&#34; + std::to_string(i) + &#34;]&#34;;
        shader-&gt;setVec3(lightName + &#34;.pos&#34;, lightPositions[i]);
        // shader-&gt;setFloat(lightName + &#34;.power&#34;, 5.0);
        // shader-&gt;setVec4(lightName + &#34;.color&#34;, glm::vec4(1, 1, 1, 1));
        lastFlicker = flicker;
        flicker = getFlicker();
        shader-&gt;setFloat(lightName+&#34;.power&#34;, 0.7 + flicker);
            //set the color between orange and red like a torch
        shader-&gt;setVec4(lightName+&#34;.color&#34;, glm::vec4(1, 0.1, 0, 1));
    }
    shader-&gt;setBool(&#34;flashLightEnabled&#34;, flashLightEnabled);
    shader-&gt;setVec3(&#34;flashLight.light.pos&#34;, camera.GetPosition());
    shader-&gt;setVec4(&#34;flashLight.light.color&#34;, glm::vec4(1, 1, 1, 1));
    // shader-&gt;setVec3(&#34;flashLight.ambient&#34;, glm::vec3(0.1, 0.1, 0.1));
    // shader-&gt;setVec3(&#34;flashLight.diffuse&#34;, glm::vec3(0.8, 0.8, 0.8));
    // shader-&gt;setVec3(&#34;flashLight.specular&#34;, glm::vec3(1, 1, 1));
    shader-&gt;setFloat(&#34;flashLight.light.power&#34;, lightPower);
    shader-&gt;setVec3(&#34;flashLight.dir&#34;, camera.GetDirection());
    shader-&gt;setFloat(&#34;flashLight.cutOff&#34;, cos(glm::radians(12.5f)));

    plane-&gt;draw();

    for(auto tree : trees)
    {
        tree-&gt;draw();
    }


    for(auto solider : army.soliders)
    {
        if(!stop_army)
        solider-&gt;update(glm::vec3(0,0,march), glm::vec3(0, 0, 0), army.arm_angle, army.leg_angle);
        solider-&gt;draw();
    }
    int angleChange = 1;
    arm_angle_backwards = army.arm_angle &gt; 160 ? true : army.arm_angle &lt; 40 ? false
                                                                            : arm_angle_backwards;
    leg_angle_backwards = army.leg_angle &gt; 270 ? true : army.leg_angle &lt; 90 ? false
                                                                            : leg_angle_backwards;
    arm_angle_backwards ? army.arm_angle-=angleChange : army.arm_angle+=angleChange;
    leg_angle_backwards ? army.leg_angle-=angleChange : army.leg_angle+=angleChange;
    if(!stop_army)
    {
        army.offset += glm::vec3(0, 0, march);
        if (army.offset.z &gt; 25)
        {
            int index = 0;
            for (int g = 0; g &lt; number_groups; g++)
            {
                for (int i = 0; i &lt; number_rows; i++)
                {
                    for (int j = 0; j &lt; number_rows - i; j++)
                    {

                        float group_offset = (number_groups - 1) * (number_rows + 1) / 2.0;
                        army.soliders[index]-&gt;set(glm::vec3((j - (number_rows - i) / 2.0), -0.5, i - 2 + g * (number_rows + 1) - group_offset - 10), glm::vec3(0, 0,0));
                        // Human* human = new Human(glm::vec3((j - (number_rows - i) / 2.0), -0.5, i - 2 + g * (number_rows + 1) - group_offset), glm::vec3(0, 0,0), 1, 1, body_texture, brick_texture_group, shader);
                        index++;
                    }
                }
            }
            army.offset.z = 0;
        }

    }
    for(auto house : houses)
    {
        house-&gt;draw(deltaTime);
    }


    skybox-&gt;getShader()-&gt;use();
    skybox-&gt;getShader()-&gt;setMat4(&#34;projection&#34;, projection);
    skybox-&gt;getShader()-&gt;setMat4(&#34;view&#34;, view);
    skybox-&gt;draw();

    // cylinderMesh-&gt;draw();
    // sphereMesh-&gt;draw();
    glUseProgram(0);
    glLoadIdentity();
    camera.Look();

    // glBegin(GL_QUADS);
    // glColor3f(1, 0, 0);
    // glVertex3f(-2, -1, -2);
    // glVertex3f(-2, -1, 2);
    // glVertex3f(2, -1, 2);
    // glVertex3f(2, -1, -2);
    // glEnd();

    glFlush();
}
bool move_toggle = false;
void handle_key_event(SDL_Event event)
{
    if(event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym ==  SDLK_w)
    {
        camera.MoveForward();
    }
    if(event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym ==  SDLK_s)
    {
        camera.MoveBackward();
    }
    if(event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym ==  SDLK_a)
    {
        camera.MoveLeft();
    }
    if(event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym ==  SDLK_d)
    {
        camera.MoveRight();
    }
    if(event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym ==  SDLK_SPACE)
    {
        if(SDL_GetModState() &amp; KMOD_CTRL)
        {
            camera.MoveDown();
        }
        else
        {
            camera.MoveUp();
        }
    }
        //toggle move toggle if cntrl is pressed
    if (event.type == SDL_KEYDOWN)
    {
        switch (event.key.keysym.sym)
        {
        case SDLK_ESCAPE:
            SDL_Log(&#34;Escape key pressed\n&#34;);
            cleanup();
            quit = true;
            break;
        case SDLK_c:
            show_commands = !show_commands;
            break;
        case SDLK_F11:
            is_fullscreen = !is_fullscreen;
            SDL_SetWindowFullscreen(Window, is_fullscreen ? SDL_WINDOW_FULLSCREEN : 0);
            break;
        case SDLK_m:
            if(SDL_GetModState() &amp; KMOD_SHIFT)
            {
                projection++;
                projection %= 4;
                Projection();
            }
            else
            {
                projection--;
                projection = projection &lt; 0 ? 3 : projection;
                Projection();
            }
            break;
        case SDLK_o:
            if (SDL_GetModState() &amp; KMOD_SHIFT)
            {
                mode++;
                mode %= 4;
            }
            else
            {
                mode--;
                mode = mode &lt; 0 ? 3 : mode;
            }
            break;
        case SDLK_1:
            camera.SetSpeed(camera.GetSpeed() + 0.1);
            break;
        case SDLK_2:
            camera.SetSpeed(camera.GetSpeed() - 0.1);
            break;
        case SDLK_SEMICOLON:
            lighting = !lighting;
            break;
        case SDLK_k:
            smooth = !smooth;
            break;
        case SDLK_j:
            local_viewer = !local_viewer;
            break;
        case SDLK_n:
            show_normals = !show_normals;
            break;
        case SDLK_p:
            if(SDL_GetModState() &amp; KMOD_SHIFT)
            {
                stop_sun = !stop_sun;
            }
            else
            {
                stop_army = !stop_army;
            }
            break;
        case SDLK_t:
            if(SDL_GetModState() &amp; KMOD_SHIFT)
            {
                time_speed -= 0.01;
                time_speed = std::max(0.01f, time_speed);
            }
            else
            {
                time_speed += 0.01;
                time_speed = std::min(1.0f, time_speed);

            }
        case SDLK_r:
            if(SDL_GetModState() &amp; KMOD_SHIFT)
            {
                time_day = 180;
            }
            else
            {
                time_day = 0;
            }
            break;
        case SDLK_l:
            if(SDL_GetModState() &amp; KMOD_SHIFT)
            {
                lightPower += 0.1;
            }
            else
            {
                lightPower -= 0.1;
            }
            break;
        case SDLK_f:
            flashLightEnabled = !flashLightEnabled;
            break;
        case SDLK_y:
            texture = !texture;
            break;

        case SDLK_g:
            grab_mouse = !grab_mouse;
            break;
        default:
            break;
        }
        //if cntrl is pressed go down
    }
    // if scroll wheel
    else if (event.type == SDL_MOUSEWHEEL)
    {
        // change the fov
        if (projection == PERSPECTIVE || projection == FIRST_PERSON)
        {
            fov += event.wheel.y;
            fov = std::max(1, fov);
            fov = std::min(180, fov);
            Projection();
        }
        else if (projection == ORTHOGONAL)
        {
            dim += event.wheel.y;
            dim = std::max(1, dim);
            dim = std::min(20, dim);
            Projection();
        }
    }
    // change ph and th by mouse movement and mouse button one being held down
    else if (event.type == SDL_MOUSEMOTION &amp;&amp; ((event.motion.state &amp; SDL_BUTTON_LMASK) || projection == FIRST_PERSON))
    {
        if (projection != FIRST_PERSON)
        {
            th += event.motion.xrel;
            ph += event.motion.yrel;
            th %= 360;
            ph %= 360;
        }
        else
        {
            camera.ChangeAngle(event.motion.xrel, -event.motion.yrel);
        }
    }
    //else if cntrl is pressed

}
void gl_error()
{
    GLenum err;
    while ((err = glGetError()) != GL_NO_ERROR)
    {
        SDL_Log(&#34;OpenGL error: %s\n&#34;, gluErrorString(err));
    }
}

void resize(int width, int height)
{
    w_width = width;
    w_height = height;
    aspect = (float)width / (float)height;
    glViewport(0, 0, width, height);
    // set frustum
    Projection();
    // update the font so it can display properly
    // arial.UpdateFont(24, width, height);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Cylinder.h</i> (<b>83.33%</b>)<br>
    Reference file: <i>objects/Sphere.h</i> (<b>63.19%</b>)<br>
    Token overlap: 115<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-4" aria-expanded="false" aria-controls="collapse-4">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-4">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>#ifndef CYLINDER_H
#define CYLINDER_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Cylinder : public Mesh
{
public:
    Cylinder(float len, </span>floa<span class='highlight-red'>t wid);
    void draw();
    void computeTangentBasis(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents);

private:
    </span>int numSideVertices;
    int numCapVertices;
    int numVertices;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code><span class='highlight-green'>#ifndef SPHERE_H
#define SPHERE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Sphere : public Mesh
{
public:
    Sphere(float radius, </span>int slicesVertical, in<span class='highlight-green'>t slicesHorizontal);
    void draw();
    void computeTangentBasis(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents);

private:

    </span>std::vector&lt;int&gt; indices;
    GLuint indexBuffer;

    float radius;
    int numSlices;
    int numStacks;
    int numVertices;
    int numIndices;
    GLuint numPoleIndices;
    GLuint numSideIndices;

    GLuint northPoleOffset;
    GLuint sideOffset;
    GLuint southPoleOffset;
};
#endif // CYLINDER_H</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>Particles.h</i> (<b>69.89%</b>)<br>
    Reference file: <i>objects/Cube.h</i> (<b>35.89%</b>)<br>
    Token overlap: 506<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-5" aria-expanded="false" aria-controls="collapse-5">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-5">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef PARTICLES_H
#define PARTICLES_H

#include &#34;lib.h&#34;
#include &#34;Shader.h&#34;
#include &#34;Camera.h&#34;
#include &lt;algorithm&gt;

// static const std::vector&lt;glm::vec3&gt; PARTICLE_VERTEX_DATA = { 
//     glm::vec3(-0.5f, -0.5f, 0.0f),
//     glm::vec3(0.5f, -0.5f, 0.0f),
//     glm::vec3(-0.5f, 0.5f, 0.0f),
//     glm::vec3(0.5f, 0.5f, 0.0f),
// };
<span class='highlight-red'>const std::vector&lt;glm::vec3&gt; PARTICLE_VERTEX_DATA = {
    glm::vec3(-1, -1, 1),
    glm::vec3(-1, 1, -1),
    glm::vec3(-1, -1, -1),
    glm::vec3(-1, 1, 1),
    glm::vec3(1, 1, -1),
    glm::vec3(-1, 1, -1),
    glm::vec3(1, 1, 1),
    glm::vec3(1, -1, -1),
    glm::vec3(1, 1, -1),
    glm::vec3(1, -1, 1),
    glm::vec3(-1, -1, -1),
    glm::vec3(1, -1, -1),
    glm::vec3(1, 1, -1),
    glm::vec3(-1, -1, -1),
    glm::vec3(-1, 1, -1),
    glm::vec3(-1, 1, 1),
    glm::vec3(1, -1, 1),
    glm::vec3(1, 1, 1),
    glm::vec3(-1, -1, 1),
    glm::vec3(-1, 1, 1),
    glm::vec3(-1, 1, -1),
    glm::vec3(-1, 1, 1),
    glm::vec3(1, 1, 1),
    glm::vec3(1, 1, -1),
    glm::vec3(1, 1, 1),
    glm::vec3(1, -1, 1),
    glm::vec3(1, -1, -1),
    glm::vec3(1, -1, 1),
    glm::vec3(-1, -1, 1),
    glm::vec3(-1, -1, -1),
    glm::vec3(1, 1, -1),
    glm::vec3(1, -1, -1),
    glm::vec3(-1, -1, -1),
    glm::vec3(-1, 1, 1),
    glm::vec3(-1, -1, 1),
    glm::vec3(1, -1, 1),
};
</span>constexpr int MAX_PARTICLES = 50;
struct Particle {
    glm::vec3 pos, speed;
    float size, angle;
    float life;
    float cameraDistance;
    bool operator&lt;(const Particle&amp; that) const {
        return this-&gt;cameraDistance &gt; that.cameraDistance;
    }
};

class Particles
{
    public:
        Particles(glm::vec3 origin, Camera* camera, Shader* shader);
        void draw(float deltaTime);
    private:
        glm::vec3 origin;
        int lastUsedParticle = 0;
        int findDeadParticle();
        std::vector&lt;Particle&gt; particles;
        GLuint VAO;
        GLuint particles_vertex_buffer;
        GLuint particles_position_buffer;
        GLuint particles_size_buffer;
        std::vector&lt;glm::vec3&gt; position_data;
        std::vector&lt;GLuint&gt; size_data;


        Shader* shader;
        Camera* camera;
};

#endif // PARTICLES_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#ifndef CUBE_H
#define CUBE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Cube: public Mesh
{
    public:
        Cube();
    protected:
        <span class='highlight-green'>const std::vector&lt;glm::vec3&gt; VERTICES = {
        glm::vec3(-1, -1, 1),
        glm::vec3(-1, 1, -1),
        glm::vec3(-1, -1, -1),
        glm::vec3(-1, 1, 1),
        glm::vec3(1, 1, -1),
        glm::vec3(-1, 1, -1),
        glm::vec3(1, 1, 1),
        glm::vec3(1, -1, -1),
        glm::vec3(1, 1, -1),
        glm::vec3(1, -1, 1),
        glm::vec3(-1, -1, -1),
        glm::vec3(1, -1, -1),
        glm::vec3(1, 1, -1),
        glm::vec3(-1, -1, -1),
        glm::vec3(-1, 1, -1),
        glm::vec3(-1, 1, 1),
        glm::vec3(1, -1, 1),
        glm::vec3(1, 1, 1),
        glm::vec3(-1, -1, 1),
        glm::vec3(-1, 1, 1),
        glm::vec3(-1, 1, -1),
        glm::vec3(-1, 1, 1),
        glm::vec3(1, 1, 1),
        glm::vec3(1, 1, -1),
        glm::vec3(1, 1, 1),
        glm::vec3(1, -1, 1),
        glm::vec3(1, -1, -1),
        glm::vec3(1, -1, 1),
        glm::vec3(-1, -1, 1),
        glm::vec3(-1, -1, -1),
        glm::vec3(1, 1, -1),
        glm::vec3(1, -1, -1),
        glm::vec3(-1, -1, -1),
        glm::vec3(-1, 1, 1),
        glm::vec3(-1, -1, 1),
        glm::vec3(1, -1, 1),
    };
    </span>const float repX = 1;
    const float repY = 1;
    const std::vector&lt;glm::vec2&gt; UVS = {
        glm::vec2(repX, 0),
        glm::vec2(0, repY),
        glm::vec2(0, 0),
        glm::vec2(repX, 0),
        glm::vec2(0, repY),
        glm::vec2(0, 0),
        glm::vec2(repX, 0),
        glm::vec2(0, repY),
        glm::vec2(0, 0),
        glm::vec2(repX, 0),
        glm::vec2(0, repY),
        glm::vec2(0, 0),
        glm::vec2(repX, 0),
        glm::vec2(0, repY),
        glm::vec2(0, 0),
        glm::vec2(repX, 0),
        glm::vec2(0, repY),
        glm::vec2(0, 0),
        glm::vec2(repX, 0),
        glm::vec2(repX, repY),
        glm::vec2(0, repY),
        glm::vec2(repX, 0),
        glm::vec2(repX, repY),
        glm::vec2(0, repY),
        glm::vec2(repX, 0),
        glm::vec2(repX, repY),
        glm::vec2(0, repY),
        glm::vec2(repX, 0),
        glm::vec2(repX, repY),
        glm::vec2(0, repY),
        glm::vec2(repX, 0),
        glm::vec2(repX, repY),
        glm::vec2(0, repY),
        glm::vec2(repX, 0),
        glm::vec2(repX, repY),
        glm::vec2(0, repY)
    };
    <span class='highlight-green'>const std::vector&lt;glm::vec3&gt; NORMALS = {
        glm::vec3(-1, -</span>0, -0),
        glm::vec3(-1, -0, -0),
        glm::vec3(-1, -0, -0),

        glm::vec3(-0, 1, -0),
        glm::vec3(-0, 1, -0),
        glm::vec3(-0, 1, -0),
        glm::vec3(1, -0, -0),
        glm::vec3(1, -0, -0),
        glm::vec3(1, -0, -0),
        
        glm::vec3(-0, -1, -0),
        glm::vec3(-0, -1, -0),
        glm::vec3(-0, -1, -0),

        glm::vec3(-0, -0, -1),
        glm::vec3(-0, -0, -1),
        glm::vec3(-0, -0, -1),
        
        glm::vec3(-0, -0, 1),
        glm::vec3(-0, -0, 1),
        glm::vec3(-0, -0, 1),

        glm::vec3(-1, -0, -0),
        glm::vec3(-1, -0, -0),
        glm::vec3(-1, -0, -0),

        glm::vec3(-0, 1, -0),
        glm::vec3(-0, 1, -0),
        glm::vec3(-0, 1, -0),

        glm::vec3(1, -0, -0),
        glm::vec3(1, -0, -0),
        glm::vec3(1, -0, -0),

        glm::vec3(-0, -1, -0),
        glm::vec3(-0, -1, -0),
        glm::vec3(-0, -1, -0),

        glm::vec3(-0, -0, -1),
        glm::vec3(-0, -0, -1),
        glm::vec3(-0, -0, -1),

        glm::vec3(-0, -0, 1),
        glm::vec3(-0, -0, 1),
        glm::vec3(-0, -0, 1),
    };
};
#endif // CUBE_H</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Cylinder.h</i> (<b>54.35%</b>)<br>
    Reference file: <i>Mesh.h</i> (<b>12.02%</b>)<br>
    Token overlap: 75<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-6" aria-expanded="false" aria-controls="collapse-6">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-6">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef CYLINDER_H
#define CYLINDER_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Cylinder : public Mesh
{
public:
    Cylinder(float len, float wid);
    void draw(<span class='highlight-red'>);
    void computeTangentBasis(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents);

private</span>:
    int numSideVertices;
    int numCapVertices;
    int numVertices;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#ifndef MESH_H
#define MESH_H

#include &#34;lib.h&#34;
#include &#34;Texture.h&#34; // Ensure that Texture.h is correctly included
#include &#34;Shader.h&#34;
class Mesh {
    public:
        Mesh(std::string path);
        Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals);
        Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;GLubyte&gt; indices);
        Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices);
        Mesh();
        ~Mesh();
        void draw();
        void draw_indexed();
        //transformations
        void translate(glm::vec3 translation) { model = glm::translate(model, translation); }
        void rotate(float angle, glm::vec3 axis) { model = glm::rotate(model, glm::radians(angle), axis); }
        void rotate(glm::vec3 angles) { model = glm::rotate(model, glm::radians(angles.z), glm::vec3(0, 0, 1)); model = glm::rotate(model, glm::radians(angles.y), glm::vec3(0, 1, 0)); model = glm::rotate(model, glm::radians(angles.x), glm::vec3(1, 0, 0));}
        void scale(glm::vec3 scale) { model = glm::scale(model, scale); }
        void resetModel() { model = glm::mat4(1.0f); }
        glm::mat4 getModel() { return model; }

        void setTextureGroup(TextureGroup *textureGroup);
        void setColorTexture(Texture *texture) { colorTexture = texture; }
        void setNormalTexture(Texture *texture) { normalTexture = texture; }
        void setModel(glm::mat4 model) { this-&gt;model = model; }

        void setInformation(TextureGroup *textureGroup, Shader *shader) { setTextureGroup(textureGroup); setShader(shader); }

        void setShader(Shader *shader) { this-&gt;shader = shader; }
        Shader* getShader() { return shader; }
    protected:
        bool loadOBJ(
            const char * <span class='highlight-green'>path, 
            std::vector&lt;glm::vec3&gt; &amp; out_vertices, 
            std::vector&lt;glm::vec2&gt; &amp; out_uvs,
            std::vector&lt;glm::vec3&gt; &amp; out_normals);
        void computeTangentBasis(
            // inputs
            std::vector&lt;glm::vec3&gt; &amp; vertices,
            std::vector&lt;glm::vec2&gt; &amp; uvs,
            std::vector&lt;glm::vec3&gt; &amp; normals,
            // outputs
            std::vector&lt;glm::vec3&gt; &amp; tangents,
            std::vector&lt;glm::vec3&gt; &amp; bitangents);
        GLuint </span>VAO, vertexBuffer, normalBuffer, uvBuffer, tangentBuffer, bitangentBuffer, elementBuffer;
        std::vector&lt;glm::vec3&gt; vertices;
        std::vector&lt;glm::vec2&gt; uvs;
        std::vector&lt;glm::vec3&gt; normals;
        std::vector&lt;glm::vec3&gt; tangents;
        std::vector&lt;glm::vec3&gt; bitangents;
        std::vector&lt;GLubyte&gt; indices;
        glm::mat4 model;
        Texture *colorTexture;
        Texture *normalTexture;
        Shader *shader;
        void loadMesh(std::string path);
        void setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals);
        void setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices);
        void setupDraw();
};
#endif // MESH_H</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Cylinder.cpp</i> (<b>48.54%</b>)<br>
    Reference file: <i>objects/Sphere.cpp</i> (<b>61.42%</b>)<br>
    Token overlap: 1067<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-7" aria-expanded="false" aria-controls="collapse-7">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-7">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#include &#34;Cylinder.h&#34;

Cylinder::Cylinder(float len, float wid): Mesh()
{

    int slizeSize = 30;
    int numSlices = 360 / slizeSize;
    float high = len;
    float radius = wid;

    std::vector&lt;float&gt; sines, cosines;
    for(int th = 0; th &lt;= 360; th += slizeSize)
    {
        sines.push_back(Sin(th));
        cosines.push_back(Cos(th));
    }

    //calculate the position
    std::vector&lt;glm::vec3&gt; vertices;
    std::vector&lt;glm::vec2&gt; positions;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        positions.push_back(glm::vec2(radius * cosines[i], radius * sines[i]));
    }

    //side vertices
    for(int i = 0; i &lt;= numSlices; i++)
    {
        glm::vec3 top = glm::vec3(positions[i].x, high, positions[i].y);
        glm::vec3 bottom = glm::vec3(positions[i].x, 0, positions[i].y);
        vertices.push_back(top);
        vertices.push_back(bottom);
    }

        glm::vec3 top = glm::vec3(0, high, 0);
        vertices.<span class='highlight-red'>push_back(top);
        for(int i = 0; i &lt;= numSlices; i++)
        {
            </span>vertices.push_back(glm::vec3(positions[i].x, high, positions[i].y));
        }

        glm::vec3 bottom = glm::vec3(0, 0, 0);
        vertices.<span class='highlight-red'>push_back(bottom);

        for(int i = 0; i &lt;= numSlices; i++)
        {
            </span>vertices.push_back(glm::vec3(positions[i].x, 0, positions[i].y));
        }

    //texture coords
    std::vector&lt;glm::vec2&gt; uvs;
    float reps = 3;
    float uvSliceStep = reps / numSlices;

    float currentUVCoord = 0;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(currentUVCoord, 1));
        uvs.push_back(glm::vec2(currentUVCoord, 0));
        currentUVCoord += uvSliceStep;
    }

    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 + cosines[i] * 0.5));
    }
    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 - cosines[i] * 0.5));
    }

    //normals
    std::vector&lt;glm::vec3&gt; normals;
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(cosines[i], 0, sines[i]));
    }

    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, 1, 0));
    }
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, -1, 0));
    }
    
    numSideVertices = (numSlices+1) * 2;
    numCapVertices = numSlices + 2;
    numVertices = numSideVertices + numCapVertices*2;

    // setupMesh(vertices, uvs, normals);
        <span class='highlight-red'>this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis</span>(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices<span class='highlight-red'>;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}
void Cylinder::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {
    //depending on the vertices we will have to change because triangle fan reuses vertices
	</span>for (int i=0; i&lt;=numSideVertices<span class='highlight-red'>; i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = (uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Cylinder Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
		#endif
        // Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);

	}
    </span>glm::vec3 top = vertices[numSideVertices];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + i + 1];
        glm::vec3 &amp; v2 = top;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices<span class='highlight-red'>];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = (uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
    </span>glm::vec3 bottom = vertices[numSideVertices + numCapVertices/2];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + numCapVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + numCapVertices + i + 1];
        glm::vec3 &amp; v2 = bottom;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + numCapVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + numCapVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices + numCapVertices<span class='highlight-red'>];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = (uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
}
</span>void Cylinder::draw() {
    glBindVertexArray(VAO);
    setupDraw();

    glDrawArrays(GL_TRIANGLE_STRIP, 0, numSideVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices, numCapVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices + numCapVertices, numCapVertices<span class='highlight-red'>);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}</span></code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Sphere.h&#34;

//adapted from https://songho.ca/opengl/gl_sphere.html
Sphere::Sphere(float radius, int numStacks, int numSlices): Mesh()
{
    // loadOBJ(&#34;sphere.obj&#34;, vertices, uvs, normals);
    <span class='highlight-green'>this-&gt;radius = radius;
    this-&gt;numSlices = numSlices;
    this-&gt;numStacks = numStacks;
    numVertices </span>= (numStacks + 1) * (numSlices + 1);
    
    float x;
    float y;
    float z;
    float xy;

    float nx;
    float ny;
    float nz;
    float lengthInv = 1.0f / radius;

    float s;
    float t;

    float sectorStep = 2 * M_PI / numSlices;
    float stackStep = M_PI / numStacks;

    for(int i=0; i&lt;= numStacks; i++)
    {
        float stackAngle = M_PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * <span class='highlight-green'>sinf(stackAngle);

        for(int j=0; j&lt;=numSlices; j++)
        {
            </span>float sectorAngle = j * sectorStep;

            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);

            vertices.push_back(glm::vec3(x, y, z));
            nx = x * lengthInv;
            ny = y * lengthInv;
            nz = z * lengthInv;
            normals.push_back(glm::vec3(nx, ny, nz));

            s = (float)j / numSlices;
            t = (float)i / numStacks;
            uvs.push_back(glm::vec2(s, t));
        }
    }

    unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }

            if(i != (numStacks - 1))
            {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }

        }
    }
    // setupMesh(vertices, uvs, normals);
    <span class='highlight-green'>this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    tangents</span>.resize(vertices.size());
    bitangents.resize(vertices.size());
    Sphere::computeTangentBasis(vertices, uvs, normals, tangents, bitangents)<span class='highlight-green'>;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    // glBindVertexArray(VAO);
    glGenBuffers(1, &amp;indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(</span>unsigned int), &amp;indices[0], GL_STATIC_DRAW);
}

void Sphere::draw()
{
    //print radius
    glBindVertexArray(VAO);
    setupDraw();
    //set the index buffer
    int temp_offset = 0;
    glDrawElements(GL_TRIANGLES, indices.size()-temp_offset, GL_UNSIGNED_INT, (void*)(temp_offset* sizeof(GLuint))<span class='highlight-green'>);

    //draw normals tangents and bitangents for debugging
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);

}

void Sphere::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {

    </span>unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                // indices.push_back(k1);
                // indices.push_back(k2);
                // indices.push_back(k1 + 1);
                		// Shortcuts for vertices
                glm::vec3 &amp; v0 = vertices[k1];
                glm::vec3 &amp; v1 = vertices[k2<span class='highlight-green'>];
                glm::vec3 &amp; v2 = vertices[k1+1];

                // Shortcuts for UVs
                // glm::vec2 &amp; uv0 = uvs[i+0];
                // glm::vec2 &amp; uv1 = uvs[i+1];
                // glm::vec2 &amp; uv2 = uvs[i+2];
                glm::vec2 &amp; uv0 = uvs[k1</span>];
                glm::vec2 &amp; uv1 = uvs[k2];
                glm::vec2 &amp; uv2 = uvs[k1+1<span class='highlight-green'>];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = (uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);

            }

            </span>if(i != (numStacks - 1))
            {
                // indices.push_back(k1 + 1);
                // indices.push_back(k2);
                // indices.push_back(k2 + 1);
                glm::vec3 &amp; v0 = vertices[k1+1];
                glm::vec3 &amp; v1 = vertices[k2<span class='highlight-green'>];
                glm::vec3 &amp; v2 = vertices[k2+1];

                // Shortcuts for UVs
                glm::vec2 &amp; uv0 = uvs[i+0];
                glm::vec2 &amp; uv1 = uvs[i+1];
                glm::vec2 &amp; uv2 = uvs[i+2];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = </span>1.0f/<span class='highlight-green'>(uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
            }

        }
    </span>}

	for (unsigned int i=0; i&lt;indices.size()<span class='highlight-green'>; i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = </span>1.0f/<span class='highlight-green'>(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	// for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	// {
	// 	glm::vec3 &amp; n = normals[i];
	// 	glm::vec3 &amp; t = tangents[i];
	// 	glm::vec3 &amp; b = bitangents[i];
		
	// 	// Gram-Schmidt orthogonalize
	// 	t = glm::normalize(t - n * glm::dot(n, t));
		
	// 	// Calculate handedness
	// 	if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
	// 		t = t * -1.0f;
	// 	}

	// }
}</span>
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Cylinder.h</i> (<b>47.83%</b>)<br>
    Reference file: <i>Mesh.cpp</i> (<b>3.11%</b>)<br>
    Token overlap: 107<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-8" aria-expanded="false" aria-controls="collapse-8">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-8">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef CYLINDER_H
#define CYLINDER_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Cylinder : public Mesh
{
public:
    Cylinder(float len, float wid);
    void draw();
    void computeTangentBasis<span class='highlight-red'>(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;

private:
    int numSideVertices;
    int numCapVertices;
    int numVertices;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Mesh.h&#34;

Mesh::Mesh(std::string path)
{
    model = glm::mat4(1.0f);
    loadMesh(path);
}
//https://learnopengl.com/Advanced-Lighting/Normal-Mapping
void Mesh::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{

	for (unsigned int i=0; i&lt;vertices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	{
		glm::vec3 &amp; n = normals[i];
		glm::vec3 &amp; t = tangents[i];
		glm::vec3 &amp; b = bitangents[i];
		
		// Gram-Schmidt orthogonalize
		t = glm::normalize(t - n * glm::dot(n, t));
		
		// Calculate handedness
		if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
			t = t * -1.0f;
		}

	}
}
void Mesh::setTextureGroup(TextureGroup *textureGroup)
{
    colorTexture = textureGroup-&gt;getTexture(TextureType::DIFFUSE);
    normalTexture = textureGroup-&gt;getTexture(TextureType::NORMAL);
}
bool Mesh::loadOBJ(
    const char *<span class='highlight-green'>path,
    std::vector&lt;glm::vec3&gt; &amp;out_vertices,
    std::vector&lt;glm::vec2&gt; &amp;out_uvs,
    std::vector&lt;glm::vec3&gt; &amp;out_normals)
</span>{
    printf(&#34;Loading OBJ file %s...\n&#34;, path);

	std::vector&lt;unsigned int&gt; vertexIndices, uvIndices, normalIndices;
	std::vector&lt;glm::vec3&gt; temp_vertices; 
	std::vector&lt;glm::vec2&gt; temp_uvs;
	std::vector&lt;glm::vec3&gt; temp_normals;


	FILE * file = fopen(path, &#34;r&#34;);
	if( file == NULL ){
		printf(&#34;Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\n&#34;);
		getchar();
		return false;
	}

	while( 1 ){

		char lineHeader[128];
		// read the first word of the line
		int res = fscanf(file, &#34;%s&#34;, lineHeader);
		if (res == EOF)
			break; // EOF = End Of File. Quit the loop.

		// else : parse lineHeader
		
		if ( strcmp( lineHeader, &#34;v&#34; ) == 0 ){
			glm::vec3 vertex;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;vertex.x, &amp;vertex.y, &amp;vertex.z );
			temp_vertices.push_back(vertex);
		}else if ( strcmp( lineHeader, &#34;vt&#34; ) == 0 ){
			glm::vec2 uv;
			fscanf(file, &#34;%f %f\n&#34;, &amp;uv.x, &amp;uv.y );
			// uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders.
            temp_uvs.push_back(uv);
		}else if ( strcmp( lineHeader, &#34;vn&#34; ) == 0 ){
			glm::vec3 normal;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;normal.x, &amp;normal.y, &amp;normal.z );
			temp_normals.push_back(normal);
		}else if ( strcmp( lineHeader, &#34;f&#34; ) == 0 ){
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];
			int matches = fscanf(file, &#34;%d/%d/%d %d/%d/%d %d/%d/%d\n&#34;, &amp;vertexIndex[0], &amp;uvIndex[0], &amp;normalIndex[0], &amp;vertexIndex[1], &amp;uvIndex[1], &amp;normalIndex[1], &amp;vertexIndex[2], &amp;uvIndex[2], &amp;normalIndex[2] );
			if (matches != 9){
				printf(&#34;File can&#39;t be read by our simple parser :-( Try exporting with other options\n&#34;);
				fclose(file);
				return false;
			}
			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices    .push_back(uvIndex[0]);
			uvIndices    .push_back(uvIndex[1]);
			uvIndices    .push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}else{
			// Probably a comment, eat up the rest of the line
			char stupidBuffer[1000];
			fgets(stupidBuffer, 1000, file);
		}

	}

	// For each vertex of each triangle
	for( unsigned int i=0; i&lt;vertexIndices.size(); i++ ){

		// Get the indices of its attributes
		unsigned int vertexIndex = vertexIndices[i];
		unsigned int uvIndex = uvIndices[i];
		unsigned int normalIndex = normalIndices[i];
		
		// Get the attributes thanks to the index
		glm::vec3 vertex = temp_vertices[ vertexIndex-1 ];
		glm::vec2 uv = temp_uvs[ uvIndex-1 ];
		glm::vec3 normal = temp_normals[ normalIndex-1 ];
		
		// Put the attributes in buffers
		out_vertices.push_back(vertex);
		out_uvs     .push_back(uv);
		out_normals .push_back(normal);
	
	}

	//print out the vertices
    std::cout &lt;&lt; &#34;Vertices: &#34; &lt;&lt; std::endl;
    for(auto v : out_vertices)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;UVs: &#34; &lt;&lt; std::endl;
    for(auto v : out_uvs)
    {
        std::cout &lt;&lt; &#34;glm::vec2(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;Normals: &#34; &lt;&lt; std::endl;
    for(auto v : out_normals)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }

	fclose(file);
	return true;
}
void Mesh::loadMesh(std::string path) {
    //if the path is an obj
    if(path.find(&#34;.obj&#34;) != std::string::npos)
    {
        if(!loadOBJ(path.c_str(), vertices, uvs, normals))
        {
            SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
            return;
        }

    }
    else
    {
        SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
        return;
    }
    //if vertices uv and normals are not empty
    if(vertices.size() &lt; 1 || uvs.size() &lt; 1 || normals.size() &lt; 1)
    {
        SDL_Log(&#34;Error: Vertices empty %s\n&#34;, path.c_str());
        return;
    }
    //compute the tangent and bitangen
    setupMesh(vertices, uvs, normals);


}

void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals) {
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}


void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLubyte), &amp;indices[0], GL_STATIC_DRAW);
}
void Mesh::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}
Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)
{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals);
}

Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals, tangents, bitangents, indices);
}

void Mesh::draw()
{
    glBindVertexArray(VAO);
    //how to call the Skybox setup function from here
    setupDraw();
    glDrawArrays(GL_TRIANGLES, 0, vertices.size());
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}

void Mesh::draw_indexed()
{
    shader-&gt;use();
    // shader-&gt;setMat4(&#34;projection&#34;, projection);
    // shader-&gt;setMat4(&#34;view&#34;, view);
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_BYTE, (void*)0);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
}

Mesh::Mesh()
{
    model = glm::mat4(1.0f);
}

Mesh::~Mesh()
{
    glDeleteBuffers(1, &amp;vertexBuffer);
    glDeleteBuffers(1, &amp;normalBuffer);
    glDeleteBuffers(1, &amp;uvBuffer);
    glDeleteBuffers(1, &amp;tangentBuffer);
    glDeleteBuffers(1, &amp;bitangentBuffer);
    glDeleteVertexArrays(1, &amp;VAO);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Cylinder.h</i> (<b>47.83%</b>)<br>
    Reference file: <i>objects/Cylinder.cpp</i> (<b>3.00%</b>)<br>
    Token overlap: 66<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-9" aria-expanded="false" aria-controls="collapse-9">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-9">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef CYLINDER_H
#define CYLINDER_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Cylinder : public Mesh
{
public:
    Cylinder(float len, float wid);
    void draw();
    void computeTangentBasis<span class='highlight-red'>(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;

private:
    int numSideVertices;
    int numCapVertices;
    int numVertices;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Cylinder.h&#34;

Cylinder::Cylinder(float len, float wid): Mesh()
{

    int slizeSize = 30;
    int numSlices = 360 / slizeSize;
    float high = len;
    float radius = wid;

    std::vector&lt;float&gt; sines, cosines;
    for(int th = 0; th &lt;= 360; th += slizeSize)
    {
        sines.push_back(Sin(th));
        cosines.push_back(Cos(th));
    }

    //calculate the position
    std::vector&lt;glm::vec3&gt; vertices;
    std::vector&lt;glm::vec2&gt; positions;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        positions.push_back(glm::vec2(radius * cosines[i], radius * sines[i]));
    }

    //side vertices
    for(int i = 0; i &lt;= numSlices; i++)
    {
        glm::vec3 top = glm::vec3(positions[i].x, high, positions[i].y);
        glm::vec3 bottom = glm::vec3(positions[i].x, 0, positions[i].y);
        vertices.push_back(top);
        vertices.push_back(bottom);
    }

        glm::vec3 top = glm::vec3(0, high, 0);
        vertices.push_back(top);
        for(int i = 0; i &lt;= numSlices; i++)
        {
            vertices.push_back(glm::vec3(positions[i].x, high, positions[i].y));
        }

        glm::vec3 bottom = glm::vec3(0, 0, 0);
        vertices.push_back(bottom);

        for(int i = 0; i &lt;= numSlices; i++)
        {
            vertices.push_back(glm::vec3(positions[i].x, 0, positions[i].y));
        }

    //texture coords
    std::vector&lt;glm::vec2&gt; uvs;
    float reps = 3;
    float uvSliceStep = reps / numSlices;

    float currentUVCoord = 0;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(currentUVCoord, 1));
        uvs.push_back(glm::vec2(currentUVCoord, 0));
        currentUVCoord += uvSliceStep;
    }

    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 + cosines[i] * 0.5));
    }
    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 - cosines[i] * 0.5));
    }

    //normals
    std::vector&lt;glm::vec3&gt; normals;
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(cosines[i], 0, sines[i]));
    }

    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, 1, 0));
    }
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, -1, 0));
    }
    
    numSideVertices = (numSlices+1) * 2;
    numCapVertices = numSlices + 2;
    numVertices = numSideVertices + numCapVertices*2;

    // setupMesh(vertices, uvs, normals);
        this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}
void Cylinder::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{
    //depending on the vertices we will have to change because triangle fan reuses vertices
	for (int i=0; i&lt;=numSideVertices; i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = (uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Cylinder Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
		#endif
        // Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);

	}
    glm::vec3 top = vertices[numSideVertices];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + i + 1];
        glm::vec3 &amp; v2 = top;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = (uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
    glm::vec3 bottom = vertices[numSideVertices + numCapVertices/2];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + numCapVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + numCapVertices + i + 1];
        glm::vec3 &amp; v2 = bottom;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + numCapVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + numCapVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices + numCapVertices];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = (uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
}
void Cylinder::draw() {
    glBindVertexArray(VAO);
    setupDraw();

    glDrawArrays(GL_TRIANGLE_STRIP, 0, numSideVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices, numCapVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices + numCapVertices, numCapVertices);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Cylinder.h</i> (<b>47.83%</b>)<br>
    Reference file: <i>objects/Sphere.cpp</i> (<b>3.17%</b>)<br>
    Token overlap: 66<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-10" aria-expanded="false" aria-controls="collapse-10">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-10">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef CYLINDER_H
#define CYLINDER_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Cylinder : public Mesh
{
public:
    Cylinder(float len, float wid);
    void draw();
    void computeTangentBasis<span class='highlight-red'>(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;

private:
    int numSideVertices;
    int numCapVertices;
    int numVertices;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Sphere.h&#34;

//adapted from https://songho.ca/opengl/gl_sphere.html
Sphere::Sphere(float radius, int numStacks, int numSlices): Mesh()
{
    // loadOBJ(&#34;sphere.obj&#34;, vertices, uvs, normals);
    this-&gt;radius = radius;
    this-&gt;numSlices = numSlices;
    this-&gt;numStacks = numStacks;
    numVertices = (numStacks + 1) * (numSlices + 1);
    
    float x;
    float y;
    float z;
    float xy;

    float nx;
    float ny;
    float nz;
    float lengthInv = 1.0f / radius;

    float s;
    float t;

    float sectorStep = 2 * M_PI / numSlices;
    float stackStep = M_PI / numStacks;

    for(int i=0; i&lt;= numStacks; i++)
    {
        float stackAngle = M_PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * sinf(stackAngle);

        for(int j=0; j&lt;=numSlices; j++)
        {
            float sectorAngle = j * sectorStep;

            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);

            vertices.push_back(glm::vec3(x, y, z));
            nx = x * lengthInv;
            ny = y * lengthInv;
            nz = z * lengthInv;
            normals.push_back(glm::vec3(nx, ny, nz));

            s = (float)j / numSlices;
            t = (float)i / numStacks;
            uvs.push_back(glm::vec2(s, t));
        }
    }

    unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }

            if(i != (numStacks - 1))
            {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }

        }
    }
    // setupMesh(vertices, uvs, normals);
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    tangents.resize(vertices.size());
    bitangents.resize(vertices.size());
    Sphere::computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    // glBindVertexArray(VAO);
    glGenBuffers(1, &amp;indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;indices[0], GL_STATIC_DRAW);
}

void Sphere::draw()
{
    //print radius
    glBindVertexArray(VAO);
    setupDraw();
    //set the index buffer
    int temp_offset = 0;
    glDrawElements(GL_TRIANGLES, indices.size()-temp_offset, GL_UNSIGNED_INT, (void*)(temp_offset* sizeof(GLuint)));

    //draw normals tangents and bitangents for debugging
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);

}

void Sphere::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{

    unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                // indices.push_back(k1);
                // indices.push_back(k2);
                // indices.push_back(k1 + 1);
                		// Shortcuts for vertices
                glm::vec3 &amp; v0 = vertices[k1];
                glm::vec3 &amp; v1 = vertices[k2];
                glm::vec3 &amp; v2 = vertices[k1+1];

                // Shortcuts for UVs
                // glm::vec2 &amp; uv0 = uvs[i+0];
                // glm::vec2 &amp; uv1 = uvs[i+1];
                // glm::vec2 &amp; uv2 = uvs[i+2];
                glm::vec2 &amp; uv0 = uvs[k1];
                glm::vec2 &amp; uv1 = uvs[k2];
                glm::vec2 &amp; uv2 = uvs[k1+1];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = (uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);

            }

            if(i != (numStacks - 1))
            {
                // indices.push_back(k1 + 1);
                // indices.push_back(k2);
                // indices.push_back(k2 + 1);
                glm::vec3 &amp; v0 = vertices[k1+1];
                glm::vec3 &amp; v1 = vertices[k2];
                glm::vec3 &amp; v2 = vertices[k2+1];

                // Shortcuts for UVs
                glm::vec2 &amp; uv0 = uvs[i+0];
                glm::vec2 &amp; uv1 = uvs[i+1];
                glm::vec2 &amp; uv2 = uvs[i+2];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = 1.0f/(uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
            }

        }
    }

	for (unsigned int i=0; i&lt;indices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	// for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	// {
	// 	glm::vec3 &amp; n = normals[i];
	// 	glm::vec3 &amp; t = tangents[i];
	// 	glm::vec3 &amp; b = bitangents[i];
		
	// 	// Gram-Schmidt orthogonalize
	// 	t = glm::normalize(t - n * glm::dot(n, t));
		
	// 	// Calculate handedness
	// 	if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
	// 		t = t * -1.0f;
	// 	}

	// }
}
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>Mesh.h</i> (<b>47.44%</b>)<br>
    Reference file: <i>Mesh.cpp</i> (<b>11.02%</b>)<br>
    Token overlap: 379<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-11" aria-expanded="false" aria-controls="collapse-11">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-11">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef MESH_H
#define MESH_H

#include &#34;lib.h&#34;
#include &#34;Texture.h&#34; // Ensure that Texture.h is correctly included
#include &#34;Shader.h&#34;
class Mesh {
    public:
        Mesh(std::string path);
        <span class='highlight-red'>Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)</span>;
        <span class='highlight-red'>Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;GLubyte&gt; indices)</span>;
        <span class='highlight-red'>Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices)</span>;
        Mesh();
        ~Mesh();
        void draw();
        void draw_indexed();
        //transformations
        void translate(glm::vec3 translation) { model = glm::translate(model, translation); }
        void rotate(float angle, glm::vec3 axis) { model = glm::rotate(model, glm::radians(angle), axis); }
        void rotate(glm::vec3 angles) { model = glm::rotate(model, glm::radians(angles.z), glm::vec3(0, 0, 1)); model = glm::rotate(model, glm::radians(angles.y), glm::vec3(0, 1, 0)); model = glm::rotate(model, glm::radians(angles.x), glm::vec3(1, 0, 0));}
        void scale(glm::vec3 scale) { model = glm::scale(model, scale); }
        void resetModel() { model = glm::mat4(1.0f); }
        glm::mat4 getModel() { return model; }

        void setTextureGroup(TextureGroup *textureGroup);
        void setColorTexture(Texture *texture) { colorTexture = texture; }
        void setNormalTexture(Texture *texture) { normalTexture = texture; }
        void setModel(glm::mat4 model) { this-&gt;model = model; }

        void setInformation(TextureGroup *textureGroup, Shader *shader) { setTextureGroup(textureGroup); setShader(shader); }

        void setShader(Shader *shader) { this-&gt;shader = shader; }
        Shader* getShader() { return shader; }
    protected:
        bool <span class='highlight-red'>loadOBJ(
            const char * path, 
            std::vector&lt;glm::vec3&gt; &amp; out_vertices, 
            std::vector&lt;glm::vec2&gt; &amp; out_uvs,
            std::vector&lt;glm::vec3&gt; &amp; out_normals)</span>;
        void computeTangentBasis<span class='highlight-red'>(
            // inputs
            std::vector&lt;glm::vec3&gt; &amp; vertices,
            std::vector&lt;glm::vec2&gt; &amp; uvs,
            std::vector&lt;glm::vec3&gt; &amp; normals,
            // outputs
            std::vector&lt;glm::vec3&gt; &amp; tangents,
            std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;
        GLuint VAO, vertexBuffer, normalBuffer, uvBuffer, <span class='highlight-red'>tangentBuffer, bitangentBuffer, elementBuffer;
        std::vector&lt;glm::vec3&gt; vertices;
        std::vector&lt;glm::vec2&gt; uvs;
        std::vector&lt;glm::vec3&gt; normals;
        std::vector&lt;glm::vec3&gt; tangents;
        std::vector&lt;glm::vec3&gt; bitangents;
        std::vector&lt;GLubyte</span>&gt; indices;
        glm::mat4 model;
        Texture *colorTexture;
        Texture *normalTexture;
        Shader *shader;
        void loadMesh(std::string path);
        void setupMesh<span class='highlight-red'>(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)</span>;
        void setupMesh<span class='highlight-red'>(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices)</span>;
        void setupDraw();
};
#endif // MESH_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Mesh.h&#34;

Mesh::Mesh(std::string path)
{
    model = glm::mat4(1.0f);
    loadMesh(path);
}
//https://learnopengl.com/Advanced-Lighting/Normal-Mapping
void Mesh::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{

	for (unsigned int i=0; i&lt;vertices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	{
		glm::vec3 &amp; n = normals[i];
		glm::vec3 &amp; t = tangents[i];
		glm::vec3 &amp; b = bitangents[i];
		
		// Gram-Schmidt orthogonalize
		t = glm::normalize(t - n * glm::dot(n, t));
		
		// Calculate handedness
		if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
			t = t * -1.0f;
		}

	}
}
void Mesh::setTextureGroup(TextureGroup *textureGroup)
{
    colorTexture = textureGroup-&gt;getTexture(TextureType::DIFFUSE);
    normalTexture = textureGroup-&gt;getTexture(TextureType::NORMAL);
}
bool Mesh::<span class='highlight-green'>loadOBJ(
    const char *path,
    std::vector&lt;glm::vec3&gt; &amp;out_vertices,
    std::vector&lt;glm::vec2&gt; &amp;out_uvs,
    std::vector&lt;glm::vec3&gt; &amp;out_normals)
</span>{
    printf(&#34;Loading OBJ file %s...\n&#34;, path);

	std::vector&lt;unsigned int&gt; <span class='highlight-green'>vertexIndices, uvIndices, normalIndices;
	std::vector&lt;glm::vec3&gt; temp_vertices; 
	std::vector&lt;glm::vec2&gt; temp_uvs;
	std::vector&lt;glm::vec3&gt; temp_normals;


	</span>FILE * file = fopen(path, &#34;r&#34;);
	if( file == NULL ){
		printf(&#34;Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\n&#34;);
		getchar();
		return false;
	}

	while( 1 ){

		char lineHeader[128];
		// read the first word of the line
		int res = fscanf(file, &#34;%s&#34;, lineHeader);
		if (res == EOF)
			break; // EOF = End Of File. Quit the loop.

		// else : parse lineHeader
		
		if ( strcmp( lineHeader, &#34;v&#34; ) == 0 ){
			glm::vec3 vertex;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;vertex.x, &amp;vertex.y, &amp;vertex.z );
			temp_vertices.push_back(vertex);
		}else if ( strcmp( lineHeader, &#34;vt&#34; ) == 0 ){
			glm::vec2 uv;
			fscanf(file, &#34;%f %f\n&#34;, &amp;uv.x, &amp;uv.y );
			// uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders.
            temp_uvs.push_back(uv);
		}else if ( strcmp( lineHeader, &#34;vn&#34; ) == 0 ){
			glm::vec3 normal;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;normal.x, &amp;normal.y, &amp;normal.z );
			temp_normals.push_back(normal);
		}else if ( strcmp( lineHeader, &#34;f&#34; ) == 0 ){
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];
			int matches = fscanf(file, &#34;%d/%d/%d %d/%d/%d %d/%d/%d\n&#34;, &amp;vertexIndex[0], &amp;uvIndex[0], &amp;normalIndex[0], &amp;vertexIndex[1], &amp;uvIndex[1], &amp;normalIndex[1], &amp;vertexIndex[2], &amp;uvIndex[2], &amp;normalIndex[2] );
			if (matches != 9){
				printf(&#34;File can&#39;t be read by our simple parser :-( Try exporting with other options\n&#34;);
				fclose(file);
				return false;
			}
			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices    .push_back(uvIndex[0]);
			uvIndices    .push_back(uvIndex[1]);
			uvIndices    .push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}else{
			// Probably a comment, eat up the rest of the line
			char stupidBuffer[1000];
			fgets(stupidBuffer, 1000, file);
		}

	}

	// For each vertex of each triangle
	for( unsigned int i=0; i&lt;vertexIndices.size(); i++ ){

		// Get the indices of its attributes
		unsigned int vertexIndex = vertexIndices[i];
		unsigned int uvIndex = uvIndices[i];
		unsigned int normalIndex = normalIndices[i];
		
		// Get the attributes thanks to the index
		glm::vec3 vertex = temp_vertices[ vertexIndex-1 ];
		glm::vec2 uv = temp_uvs[ uvIndex-1 ];
		glm::vec3 normal = temp_normals[ normalIndex-1 ];
		
		// Put the attributes in buffers
		out_vertices.push_back(vertex);
		out_uvs     .push_back(uv);
		out_normals .push_back(normal);
	
	}

	//print out the vertices
    std::cout &lt;&lt; &#34;Vertices: &#34; &lt;&lt; std::endl;
    for(auto v : out_vertices)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;UVs: &#34; &lt;&lt; std::endl;
    for(auto v : out_uvs)
    {
        std::cout &lt;&lt; &#34;glm::vec2(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;Normals: &#34; &lt;&lt; std::endl;
    for(auto v : out_normals)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }

	fclose(file);
	return true;
}
void Mesh::loadMesh(std::string path) {
    //if the path is an obj
    if(path.find(&#34;.obj&#34;) != std::string::npos)
    {
        if(!loadOBJ(path.c_str(), vertices, uvs, normals))
        {
            SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
            return;
        }

    }
    else
    {
        SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
        return;
    }
    //if vertices uv and normals are not empty
    if(vertices.size() &lt; 1 || uvs.size() &lt; 1 || normals.size() &lt; 1)
    {
        SDL_Log(&#34;Error: Vertices empty %s\n&#34;, path.c_str());
        return;
    }
    //compute the tangent and bitangen
    setupMesh(vertices, uvs, normals);


}

void Mesh::<span class='highlight-green'>setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals) </span>{
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}


void Mesh::<span class='highlight-green'>setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) </span>{
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLubyte), &amp;indices[0], GL_STATIC_DRAW);
}
void Mesh::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}
Mesh::<span class='highlight-green'>Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)
</span>{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals);
}

Mesh::<span class='highlight-green'>Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) </span>{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals, tangents, bitangents, indices);
}

void Mesh::draw()
{
    glBindVertexArray(VAO);
    //how to call the Skybox setup function from here
    setupDraw();
    glDrawArrays(GL_TRIANGLES, 0, vertices.size());
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}

void Mesh::draw_indexed()
{
    shader-&gt;use();
    // shader-&gt;setMat4(&#34;projection&#34;, projection);
    // shader-&gt;setMat4(&#34;view&#34;, view);
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_BYTE, (void*)0);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
}

Mesh::Mesh()
{
    model = glm::mat4(1.0f);
}

Mesh::~Mesh()
{
    glDeleteBuffers(1, &amp;vertexBuffer);
    glDeleteBuffers(1, &amp;normalBuffer);
    glDeleteBuffers(1, &amp;uvBuffer);
    glDeleteBuffers(1, &amp;tangentBuffer);
    glDeleteBuffers(1, &amp;bitangentBuffer);
    glDeleteVertexArrays(1, &amp;VAO);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Tree.h</i> (<b>46.05%</b>)<br>
    Reference file: <i>objects/Tree.cpp</i> (<b>18.13%</b>)<br>
    Token overlap: 35<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-12" aria-expanded="false" aria-controls="collapse-12">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-12">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#include &#34;../lib.h&#34;
#include &#34;Cylinder.h&#34;
#include &#34;Sphere.h&#34;

class Tree : public Cylinder
{
    public<span class='highlight-red'>:
        Tree(glm::vec3 pos, float len, float wid, TextureGroup* barkTexture, TextureGroup* leavesTexture, Shader* shader)</span>;
        void draw();
    private:
        TextureGroup* barkTexture;
        TextureGroup* leavesTexture;
        Sphere* leaves;
};</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Tree.h&#34;


Tree:<span class='highlight-green'>:Tree(glm::vec3 pos, float len, float wid, TextureGroup *barkTexture, TextureGroup *leavesTexture, Shader *shader) </span>: Cylinder(len, wid)
{
    this-&gt;barkTexture = barkTexture;
    this-&gt;leavesTexture = leavesTexture;
    this-&gt;shader = shader;
    setTextureGroup(barkTexture);
    translate(glm::vec3(0, -1, 0));
    translate(pos);

    leaves = new Sphere(wid * 4, 10, 10);
    leaves-&gt;setModel(getModel());
    leaves-&gt;setTextureGroup(leavesTexture);
    leaves-&gt;setShader(shader);
    leaves-&gt;translate(glm::vec3(0, len, 0));

}

void Tree::draw()
{
    Cylinder::draw();
    leaves-&gt;draw();
}
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Sphere.h</i> (<b>41.21%</b>)<br>
    Reference file: <i>Mesh.h</i> (<b>12.02%</b>)<br>
    Token overlap: 115<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-13" aria-expanded="false" aria-controls="collapse-13">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-13">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef SPHERE_H
#define SPHERE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Sphere : public Mesh
{
public:
    Sphere(float radius, int slicesVertical, int slicesHorizontal);
    void draw(<span class='highlight-red'>);
    void computeTangentBasis(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents);

private</span>:

    std::vector&lt;int&gt; indices;
    GLuint indexBuffer;

    float radius;
    int numSlices;
    int numStacks;
    int numVertices;
    int numIndices;
    GLuint numPoleIndices;
    GLuint numSideIndices;

    GLuint northPoleOffset;
    GLuint sideOffset;
    GLuint southPoleOffset;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#ifndef MESH_H
#define MESH_H

#include &#34;lib.h&#34;
#include &#34;Texture.h&#34; // Ensure that Texture.h is correctly included
#include &#34;Shader.h&#34;
class Mesh {
    public:
        Mesh(std::string path);
        Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals);
        Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;GLubyte&gt; indices);
        Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices);
        Mesh();
        ~Mesh();
        void draw();
        void draw_indexed();
        //transformations
        void translate(glm::vec3 translation) { model = glm::translate(model, translation); }
        void rotate(float angle, glm::vec3 axis) { model = glm::rotate(model, glm::radians(angle), axis); }
        void rotate(glm::vec3 angles) { model = glm::rotate(model, glm::radians(angles.z), glm::vec3(0, 0, 1)); model = glm::rotate(model, glm::radians(angles.y), glm::vec3(0, 1, 0)); model = glm::rotate(model, glm::radians(angles.x), glm::vec3(1, 0, 0));}
        void scale(glm::vec3 scale) { model = glm::scale(model, scale); }
        void resetModel() { model = glm::mat4(1.0f); }
        glm::mat4 getModel() { return model; }

        void setTextureGroup(TextureGroup *textureGroup);
        void setColorTexture(Texture *texture) { colorTexture = texture; }
        void setNormalTexture(Texture *texture) { normalTexture = texture; }
        void setModel(glm::mat4 model) { this-&gt;model = model; }

        void setInformation(TextureGroup *textureGroup, Shader *shader) { setTextureGroup(textureGroup); setShader(shader); }

        void setShader(Shader *shader) { this-&gt;shader = shader; }
        Shader* getShader() { return shader; }
    protected:
        bool loadOBJ(
            const char * <span class='highlight-green'>path, 
            std::vector&lt;glm::vec3&gt; &amp; out_vertices, 
            std::vector&lt;glm::vec2&gt; &amp; out_uvs,
            std::vector&lt;glm::vec3&gt; &amp; out_normals);
        void computeTangentBasis(
            // inputs
            std::vector&lt;glm::vec3&gt; &amp; vertices,
            std::vector&lt;glm::vec2&gt; &amp; uvs,
            std::vector&lt;glm::vec3&gt; &amp; normals,
            // outputs
            std::vector&lt;glm::vec3&gt; &amp; tangents,
            std::vector&lt;glm::vec3&gt; &amp; bitangents);
        GLuint </span>VAO, vertexBuffer, normalBuffer, uvBuffer, tangentBuffer, bitangentBuffer, elementBuffer;
        std::vector&lt;glm::vec3&gt; vertices;
        std::vector&lt;glm::vec2&gt; uvs;
        std::vector&lt;glm::vec3&gt; normals;
        std::vector&lt;glm::vec3&gt; tangents;
        std::vector&lt;glm::vec3&gt; bitangents;
        std::vector&lt;GLubyte&gt; indices;
        glm::mat4 model;
        Texture *colorTexture;
        Texture *normalTexture;
        Shader *shader;
        void loadMesh(std::string path);
        void setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals);
        void setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices);
        void setupDraw();
};
#endif // MESH_H</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Skybox.cpp</i> (<b>39.62%</b>)<br>
    Reference file: <i>Mesh.cpp</i> (<b>17.59%</b>)<br>
    Token overlap: 605<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-14" aria-expanded="false" aria-controls="collapse-14">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-14">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#include &#34;Skybox.h&#34;

Skybox::Skybox(Camera* camera) : Cube()
{
    this-&gt;camera = camera;
    Shader *shader = new Shader(&#34;./shaders/skybox.vert&#34;, &#34;./shaders/skybox.frag&#34;);
    setShader(shader);
    // translate(camera-&gt;GetPosition());
    scale(glm::vec3(12, 12, 12));
    //the order is important and the photos are labels nx, px, py, ny, nz, pz
    std::vector&lt;std::string&gt; faces = {
        &#34;./textures/skybox/px.png&#34;,
        &#34;./textures/skybox/nx.png&#34;,
        &#34;./textures/skybox/py.png&#34;,
        &#34;./textures/skybox/ny.png&#34;,
        &#34;./textures/skybox/pz.png&#34;,
        &#34;./textures/skybox/nz.png&#34;,

    };
    cubemapTexture = loadCubemap(<span class='highlight-red'>faces);
    
}

void Skybox::draw()
{
    glDepthFunc(GL_LEQUAL);
    // resetModel();
    // translate(camera-&gt;GetPosition());
    // scale(glm::vec3(20, 20, 20));
    setupDraw();
    glDrawArrays(GL_TRIANGLES, 0, vertices.size());
    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glDepthFunc(</span><span class='highlight-red'>GL_LESS);
}

void Skybox::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture</span>(GL_TEXTURE_CUBE_MAP, cubemapTexture);
    shader-&gt;setInt(&#34;skybox&#34;, 0<span class='highlight-red'>);


    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}

</span>unsigned int Skybox::loadCubemap(std::vector&lt;std::string&gt; faces)
{
        unsigned int textureID;
    glGenTextures(1, &amp;textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

    <span class='highlight-red'>for (unsigned int i = 0; i &lt; faces.size(); i++)
    {
        </span>SDL_Surface* surface = IMG_Load(faces[i].c_str());
        if (surface)
        {
            GLenum format;
            if (surface-&gt;format-&gt;BytesPerPixel == 4) { // 32-bit
                if (surface-&gt;format-&gt;Rmask == 0x000000ff)
                    format = GL_RGBA;
                else
                    format = GL_BGRA;
            } else if (surface-&gt;format-&gt;BytesPerPixel == 3) { // 24-bit
                if (surface-&gt;format-&gt;Rmask == 0x000000ff)
                    format = GL_RGB;
                else
                    format = GL_BGR;
            } else {
                SDL_Log(&#34;Image is not true color: %s&#34;, faces[i].c_str());
                SDL_FreeSurface(surface);
                return 0;
            }
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 
                         0, format, surface-&gt;w, surface-&gt;h, 0, format, GL_UNSIGNED_BYTE, surface-&gt;pixels
            );
        }
        else
        {
            std::cout &lt;&lt; &#34;Cubemap tex failed to load at path: &#34; &lt;&lt; faces[i] &lt;&lt; std::endl;
        }
        SDL_FreeSurface(surface);           
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

    return textureID;
}
</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Mesh.h&#34;

Mesh::Mesh(std::string path)
{
    model = glm::mat4(1.0f);
    loadMesh(path);
}
//https://learnopengl.com/Advanced-Lighting/Normal-Mapping
void Mesh::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {

	<span class='highlight-green'>for (unsigned int i=0; i&lt;vertices.size(); i+</span>=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	<span class='highlight-green'>for (unsigned int i=0; i&lt;vertices.size(); i+</span>=1 )
	{
		glm::vec3 &amp; n = normals[i];
		glm::vec3 &amp; t = tangents[i];
		glm::vec3 &amp; b = bitangents[i];
		
		// Gram-Schmidt orthogonalize
		t = glm::normalize(t - n * glm::dot(n, t));
		
		// Calculate handedness
		if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
			t = t * -1.0f;
		}

	}
}
void Mesh::setTextureGroup(TextureGroup *textureGroup)
{
    colorTexture = textureGroup-&gt;getTexture(TextureType::DIFFUSE);
    normalTexture = textureGroup-&gt;getTexture(TextureType::NORMAL);
}
bool Mesh::loadOBJ(
    const char *path,
    std::vector&lt;glm::vec3&gt; &amp;out_vertices,
    std::vector&lt;glm::vec2&gt; &amp;out_uvs,
    std::vector&lt;glm::vec3&gt; &amp;out_normals)
{
    printf(&#34;Loading OBJ file %s...\n&#34;, path);

	std::vector&lt;unsigned int&gt; vertexIndices, uvIndices, normalIndices;
	std::vector&lt;glm::vec3&gt; temp_vertices; 
	std::vector&lt;glm::vec2&gt; temp_uvs;
	std::vector&lt;glm::vec3&gt; temp_normals;


	FILE * file = fopen(path, &#34;r&#34;);
	if( file == NULL ){
		printf(&#34;Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\n&#34;);
		getchar();
		return false;
	}

	while( 1 ){

		char lineHeader[128];
		// read the first word of the line
		int res = fscanf(file, &#34;%s&#34;, lineHeader);
		if (res == EOF)
			break; // EOF = End Of File. Quit the loop.

		// else : parse lineHeader
		
		if ( strcmp( lineHeader, &#34;v&#34; ) == 0 ){
			glm::vec3 vertex;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;vertex.x, &amp;vertex.y, &amp;vertex.z );
			temp_vertices.push_back(vertex);
		}else if ( strcmp( lineHeader, &#34;vt&#34; ) == 0 ){
			glm::vec2 uv;
			fscanf(file, &#34;%f %f\n&#34;, &amp;uv.x, &amp;uv.y );
			// uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders.
            temp_uvs.push_back(uv);
		}else if ( strcmp( lineHeader, &#34;vn&#34; ) == 0 ){
			glm::vec3 normal;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;normal.x, &amp;normal.y, &amp;normal.z );
			temp_normals.push_back(normal);
		}else if ( strcmp( lineHeader, &#34;f&#34; ) == 0 ){
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];
			int matches = fscanf(file, &#34;%d/%d/%d %d/%d/%d %d/%d/%d\n&#34;, &amp;vertexIndex[0], &amp;uvIndex[0], &amp;normalIndex[0], &amp;vertexIndex[1], &amp;uvIndex[1], &amp;normalIndex[1], &amp;vertexIndex[2], &amp;uvIndex[2], &amp;normalIndex[2] );
			if (matches != 9){
				printf(&#34;File can&#39;t be read by our simple parser :-( Try exporting with other options\n&#34;);
				fclose(file);
				return false;
			}
			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices    .push_back(uvIndex[0]);
			uvIndices    .push_back(uvIndex[1]);
			uvIndices    .push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}else{
			// Probably a comment, eat up the rest of the line
			char stupidBuffer[1000];
			fgets(stupidBuffer, 1000, file);
		}

	}

	// For each vertex of each triangle
	<span class='highlight-green'>for( unsigned int i=0; i&lt;vertexIndices.size(); i++ ){

		// Get the indices of its attributes
		</span>unsigned int vertexIndex = vertexIndices[i];
		unsigned int uvIndex = uvIndices[i];
		unsigned int normalIndex = normalIndices[i];
		
		// Get the attributes thanks to the index
		glm::vec3 vertex = temp_vertices[ vertexIndex-1 ];
		glm::vec2 uv = temp_uvs[ uvIndex-1 ];
		glm::vec3 normal = temp_normals[ normalIndex-1 ];
		
		// Put the attributes in buffers
		out_vertices.push_back(vertex);
		out_uvs     .push_back(uv);
		out_normals .push_back(normal);
	
	}

	//print out the vertices
    std::cout &lt;&lt; &#34;Vertices: &#34; &lt;&lt; std::endl;
    for(auto v : out_vertices)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;UVs: &#34; &lt;&lt; std::endl;
    for(auto v : out_uvs)
    {
        std::cout &lt;&lt; &#34;glm::vec2(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;Normals: &#34; &lt;&lt; std::endl;
    for(auto v : out_normals)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }

	fclose(file);
	return true;
}
void Mesh::loadMesh(std::string path) {
    //if the path is an obj
    if(path.find(&#34;.obj&#34;) != std::string::npos)
    {
        if(!loadOBJ(path.c_str(), vertices, uvs, normals))
        {
            SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
            return;
        }

    }
    else
    {
        SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
        return;
    }
    //if vertices uv and normals are not empty
    if(vertices.size() &lt; 1 || uvs.size() &lt; 1 || normals.size() &lt; 1)
    {
        SDL_Log(&#34;Error: Vertices empty %s\n&#34;, path.c_str());
        return;
    }
    //compute the tangent and bitangen
    setupMesh(vertices, uvs, normals);


}

void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals) {
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}


void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLubyte), &amp;indices[0], <span class='highlight-green'>GL_STATIC_DRAW);
}
void Mesh::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture</span>-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1<span class='highlight-green'>);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}
</span>Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)
{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals);
}

Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals, tangents, bitangents, <span class='highlight-green'>indices);
}

void Mesh::draw()
{
    glBindVertexArray(VAO);
    //how to call the Skybox setup function from here
    setupDraw();
    glDrawArrays(GL_TRIANGLES, 0, vertices.size());
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(</span>0<span class='highlight-green'>);
}

void Mesh::draw_indexed()
{
    shader-&gt;use();
    // shader-&gt;setMat4(&#34;projection&#34;, projection);
    // shader-&gt;setMat4(&#34;view&#34;, view);
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture</span>-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1<span class='highlight-green'>);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    </span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_BYTE, (void*)0<span class='highlight-green'>);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
</span>}

Mesh::Mesh()
{
    model = glm::mat4(1.0f);
}

Mesh::~Mesh()
{
    glDeleteBuffers(1, &amp;vertexBuffer);
    glDeleteBuffers(1, &amp;normalBuffer);
    glDeleteBuffers(1, &amp;uvBuffer);
    glDeleteBuffers(1, &amp;tangentBuffer);
    glDeleteBuffers(1, &amp;bitangentBuffer);
    glDeleteVertexArrays(1, &amp;VAO);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Human.h</i> (<b>38.73%</b>)<br>
    Reference file: <i>objects/House.h</i> (<b>48.72%</b>)<br>
    Token overlap: 79<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-15" aria-expanded="false" aria-controls="collapse-15">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-15">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code><span class='highlight-red'>#ifndef HUMAN_H
#define HUMAN_H

#include &#34;../lib.h&#34;

#include &#34;Cylinder.h&#34;
#include &#34;Sphere.h&#34;

class Human : public Cylinder{
    public:
        Human(glm::vec3 pos, glm::vec3 rot, </span>int arm_seperation, int leg_seperation, TextureGroup *bodyTexture, TextureGroup *headTexture, Shader *shader);
        void draw();

        void rotateArms(int angle);
        void rotateLegs(int angle);
        void update(glm::vec3 pos, glm::vec3 rot, int arm_seperation, int leg_seperation);
        void set(glm::vec3 pos, glm::vec3 rot);
    <span class='highlight-red'>private:
        TextureGroup *bodyTexture;
        TextureGroup *headTexture;
        Shader *shader;
        Sphere *hips;
        Sphere *head;
        Cylinder *leftArm;
        Cylinder *rightArm;
        Cylinder *leftLeg;
        Cylinder *rightLeg;
        glm::vec3 </span>pos;
        glm::vec3 rot;
        int arm_seperation;
        int leg_seperation;
};
#endif // HUMAN_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#ifndef HOUSE_H
#define HOUSE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;
<span class='highlight-green'>#include &#34;Cube.h&#34;
#include &#34;Cylinder.h&#34;
#include &#34;Sphere.h&#34;
#include &#34;../Mesh.h&#34;
#include &#34;../Particles.h&#34;

class House : public Cube
{
public:
    House(glm::vec3 pos, glm::vec3 scale, </span>glm::vec3 rot, TextureGroup* brickTexture, TextureGroup* roofTexture, TextureGroup *torchTexture, TextureGroup* fireTexture, Shader* shader, Shader* smokeShader, Camera* camera);
    void draw(float deltaTime);
    std::vector&lt;glm::vec3&gt; getLights() { return lightPositions; }

<span class='highlight-green'>private:

    Texture *brickColor;
    Texture *brickNormal;

    Texture *roofColor;
    Texture *roofNormal;

    Texture* torchColor;
    Texture* torchNormal;

    Cylinder* torch1;
    Sphere* torch1Fire;
    Particles* torch1Smoke;
    
    Cylinder* torch2;
    Sphere* torch2Fire;
    Particles* torch2Smoke;

    Mesh* roof;

    std::vector</span>&lt;glm::vec3&gt; lightPositions;

    Camera* camera;

};
#endif // HOUSE_H</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>Mesh.cpp</i> (<b>38.49%</b>)<br>
    Reference file: <i>objects/Sphere.cpp</i> (<b>65.55%</b>)<br>
    Token overlap: 1324<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-16" aria-expanded="false" aria-controls="collapse-16">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-16">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#include &#34;Mesh.h&#34;

Mesh::Mesh(std::string path)
{
    model = glm::mat4(1.0f);
    loadMesh(path<span class='highlight-red'>);
}
//https://learnopengl.com/Advanced-Lighting/Normal-Mapping
void Mesh::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {

	</span><span class='highlight-red'>for (unsigned int i=0; i&lt;vertices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	for (unsigned int i=0; i&lt;vertices.size(); i+=</span>1 <span class='highlight-red'>)
	{
		glm::vec3 &amp; n = normals[i];
		glm::vec3 &amp; t = tangents[i];
		glm::vec3 &amp; b = bitangents[i];
		
		// Gram-Schmidt orthogonalize
		t </span>= glm::normalize(t - n * glm::dot(n, t));
		
		// Calculate handedness
		if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
			t = t * -1.0f;
		}

	}
}
void Mesh::setTextureGroup(TextureGroup *textureGroup)
{
    colorTexture = textureGroup-&gt;getTexture(TextureType::DIFFUSE);
    normalTexture = textureGroup-&gt;getTexture(TextureType::NORMAL);
}
bool Mesh::loadOBJ(
    const char *<span class='highlight-red'>path,
    std::vector&lt;glm::vec3&gt; &amp;out_vertices,
    std::vector&lt;glm::vec2&gt; &amp;out_uvs,
    std::vector&lt;glm::vec3&gt; &amp;out_normals)
{
    </span>printf(&#34;Loading OBJ file %s...\n&#34;, path);

	std::vector&lt;unsigned int&gt; vertexIndices, uvIndices, normalIndices;
	std::vector&lt;glm::vec3&gt; temp_vertices; 
	std::vector&lt;glm::vec2&gt; temp_uvs;
	std::vector&lt;glm::vec3&gt; temp_normals;


	FILE * file = fopen(path, &#34;r&#34;);
	if( file == NULL ){
		printf(&#34;Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\n&#34;);
		getchar();
		return false;
	}

	while( 1 ){

		char lineHeader[128];
		// read the first word of the line
		int res = fscanf(file, &#34;%s&#34;, lineHeader);
		if (res == EOF)
			break; // EOF = End Of File. Quit the loop.

		// else : parse lineHeader
		
		if ( strcmp( lineHeader, &#34;v&#34; ) == 0 ){
			glm::vec3 vertex;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;vertex.x, &amp;vertex.y, &amp;vertex.z );
			temp_vertices.push_back(vertex);
		}else if ( strcmp( lineHeader, &#34;vt&#34; ) == 0 ){
			glm::vec2 uv;
			fscanf(file, &#34;%f %f\n&#34;, &amp;uv.x, &amp;uv.y );
			// uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders.
            temp_uvs.push_back(uv);
		}else if ( strcmp( lineHeader, &#34;vn&#34; ) == 0 ){
			glm::vec3 normal;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;normal.x, &amp;normal.y, &amp;normal.z );
			temp_normals.push_back(normal);
		}else if ( strcmp( lineHeader, &#34;f&#34; ) == 0 ){
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];
			int matches = fscanf(file, &#34;%d/%d/%d %d/%d/%d %d/%d/%d\n&#34;, &amp;vertexIndex[0], &amp;uvIndex[0], &amp;normalIndex[0], &amp;vertexIndex[1], &amp;uvIndex[1], &amp;normalIndex[1], &amp;vertexIndex[2], &amp;uvIndex[2], &amp;normalIndex[2] );
			if (matches != 9){
				printf(&#34;File can&#39;t be read by our simple parser :-( Try exporting with other options\n&#34;);
				fclose(file);
				return false;
			}
			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices    .push_back(uvIndex[0]);
			uvIndices    .push_back(uvIndex[1]);
			uvIndices    .push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}else{
			// Probably a comment, eat up the rest of the line
			char stupidBuffer[1000];
			fgets(stupidBuffer, 1000, file);
		<span class='highlight-red'>}

	}

	// For each vertex of each triangle
	for( unsigned int i=0; i&lt;vertexIndices.size(); i+</span>+ ){

		// Get the indices of its attributes
		unsigned int vertexIndex = vertexIndices[i];
		unsigned int uvIndex = uvIndices[i];
		unsigned int normalIndex = normalIndices[i];
		
		// Get the attributes thanks to the index
		glm::vec3 vertex = temp_vertices[ vertexIndex-1 ];
		glm::vec2 uv = temp_uvs[ uvIndex-1 ];
		glm::vec3 normal = temp_normals[ normalIndex-1 ];
		
		// Put the attributes in buffers
		out_vertices.push_back(vertex);
		out_uvs     .push_back(uv);
		out_normals .push_back(normal);
	
	}

	//print out the vertices
    std::cout &lt;&lt; &#34;Vertices: &#34; &lt;&lt; std::endl;
    for(auto v : out_vertices)
    {
        <span class='highlight-red'>std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std</span>::endl;
    }
    std::cout &lt;&lt; &#34;UVs: &#34; &lt;&lt; std::endl;
    for(auto v : out_uvs)
    {
        <span class='highlight-red'>std::cout &lt;&lt; &#34;glm::vec2(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;),&#34; &lt;&lt; std</span>::endl;
    }
    std::cout &lt;&lt; &#34;Normals: &#34; &lt;&lt; std::endl;
    for(auto v : out_normals)
    {
        <span class='highlight-red'>std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std</span>::endl;
    }

	fclose(file);
	return true;
}
void Mesh::loadMesh(std::string path) {
    //if the path is an obj
    if(path.find(&#34;.obj&#34;) != std::string::npos)
    {
        if(!loadOBJ(path.c_str(), vertices, uvs, normals))
        {
            SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
            return;
        }

    }
    else
    {
        SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
        return;
    }
    //if vertices uv and normals are not empty
    if(vertices.size() &lt; 1 || uvs.size() &lt; 1 || normals.size() &lt; 1)
    {
        SDL_Log(&#34;Error: Vertices empty %s\n&#34;, path.c_str());
        return;
    }
    //compute the tangent and bitangen
    setupMesh(vertices, uvs, normals);


}

void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals<span class='highlight-red'>) {
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis</span>(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices<span class='highlight-red'>;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
</span>}


void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    <span class='highlight-red'>glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLubyte</span>), &amp;indices[0], GL_STATIC_DRAW);
}
void Mesh::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}
Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)
{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals);
}

Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals, tangents, bitangents<span class='highlight-red'>, indices);
}

void Mesh::draw()
{
    glBindVertexArray(VAO);
    //how to call the Skybox setup function from here
    setupDraw();
    </span>glDrawArrays(GL_TRIANGLES, 0, vertices.size(<span class='highlight-red'>));
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}

void Mesh::draw_indexed(</span>)
{
    shader-&gt;use();
    // shader-&gt;setMat4(&#34;projection&#34;, projection);
    // shader-&gt;setMat4(&#34;view&#34;, view);
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_BYTE, (void*)0<span class='highlight-red'>);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
</span>}

Mesh::Mesh()
{
    model = glm::mat4(1.0f);
}

Mesh::~Mesh()
{
    glDeleteBuffers(1, &amp;vertexBuffer);
    glDeleteBuffers(1, &amp;normalBuffer);
    glDeleteBuffers(1, &amp;uvBuffer);
    glDeleteBuffers(1, &amp;tangentBuffer);
    glDeleteBuffers(1, &amp;bitangentBuffer);
    glDeleteVertexArrays(1, &amp;VAO);
}</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Sphere.h&#34;

//adapted from https://songho.ca/opengl/gl_sphere.html
Sphere::Sphere(float radius, int numStacks, int numSlices): Mesh(<span class='highlight-green'>)
{
    // loadOBJ(&#34;sphere.obj&#34;, vertices, uvs, normals);
    this-&gt;radius = radius;
    this-&gt;numSlices = numSlices;
    this-&gt;numStacks = numStacks;
    numVertices </span>= (numStacks + 1) * (numSlices + 1);
    
    float x;
    float y;
    float z;
    float xy;

    float nx;
    float ny;
    float nz;
    float lengthInv = 1.0f / radius;

    float s;
    float t;

    float sectorStep = 2 * M_PI / numSlices;
    float stackStep = M_PI / numStacks;

    for(int i=0; i&lt;= numStacks; i++)
    {
        float stackAngle = M_PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * sinf(stackAngle);

        for(int j=0; j&lt;=numSlices; j++)
        {
            float sectorAngle = j * sectorStep;

            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);

            vertices.push_back(glm::vec3(x, y, z));
            nx = x * lengthInv;
            ny = y * lengthInv;
            nz = z * lengthInv;
            normals.push_back(glm::vec3(nx, ny, nz));

            s = (float)j / numSlices;
            t = (float)i / numStacks;
            uvs.push_back(glm::vec2(s, t));
        }
    }

    unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }

            if(i != (numStacks - 1))
            {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }

        }
    }
    // setupMesh(vertices, uvs, normals);
    <span class='highlight-green'>this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    tangents</span>.resize(vertices.size());
    bitangents.resize(vertices.size());
    Sphere::computeTangentBasis(vertices, uvs, normals, tangents, bitangents)<span class='highlight-green'>;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    // glBindVertexArray(VAO);
    glGenBuffers(1, &amp;indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(</span>unsigned int), &amp;indices[0]<span class='highlight-green'>, GL_STATIC_DRAW);
}

void Sphere::draw()
{
    //print radius
    glBindVertexArray(VAO);
    setupDraw();
    //set the index buffer
    </span>int temp_offset = 0;
    glDrawElements(GL_TRIANGLES, indices.size()-temp_offset, GL_UNSIGNED_INT, (void*)(temp_offset* sizeof(GLuint)<span class='highlight-green'>));

    //draw normals tangents and bitangents for debugging
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);

}

void Sphere::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {

    </span>unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0<span class='highlight-green'>)
            {
                // indices.push_back(k1);
                // indices.push_back(k2);
                // indices.push_back(k1 + 1);
                		// Shortcuts for vertices
                glm::vec3 &amp; v0 = vertices[k1];
                glm::vec3 &amp; v1 = vertices[k2];
                glm::vec3 &amp; v2 = vertices[k1+1];

                // Shortcuts for UVs
                // glm::vec2 &amp; uv0 = uvs[i+0];
                // glm::vec2 &amp; uv1 = uvs[i+1];
                // glm::vec2 &amp; uv2 = uvs[i+2];
                glm::vec2 &amp; uv0 = uvs[k1];
                glm::vec2 &amp; uv1 = uvs[k2];
                glm::vec2 &amp; uv2 = uvs[k1</span>+1<span class='highlight-green'>];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = </span><span class='highlight-green'>(uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);

            }

            </span>if(i != (numStacks - 1))
            {
                // indices.push_back(k1 + 1);
                // indices.push_back(k2);
                // indices.push_back(k2 + 1);
                glm::vec3 &amp; v0 = vertices[k1+1];
                glm::vec3 &amp; v1 = vertices[k2<span class='highlight-green'>];
                glm::vec3 &amp; v2 = vertices[k2+1];

                // Shortcuts for UVs
                glm::vec2 &amp; uv0 = uvs[i+0];
                glm::vec2 &amp; uv1 = uvs[i+1];
                glm::vec2 &amp; uv2 = uvs[i+2];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = 1.0f/(uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
            }

        </span><span class='highlight-green'>}
    }

	for (unsigned int i=0; i&lt;indices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	// for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	// {
	// 	glm::vec3 &amp; n = normals[i];
	// 	glm::vec3 &amp; t = tangents[i];
	// 	glm::vec3 &amp; b = bitangents[i];
		
	// 	// Gram-Schmidt orthogonalize
	// 	t = glm::normalize(t - n * glm::dot(n, t));
		
	// 	// Calculate handedness
	// 	if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
	// 		t = t * -1.0f;
	// 	}

	// }
</span>}
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>Mesh.cpp</i> (<b>36.86%</b>)<br>
    Reference file: <i>objects/Cylinder.cpp</i> (<b>49.41%</b>)<br>
    Token overlap: 1268<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-17" aria-expanded="false" aria-controls="collapse-17">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-17">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#include &#34;Mesh.h&#34;

Mesh::Mesh(std::string path)
{
    model = glm::mat4(1.0f);
    loadMesh(<span class='highlight-red'>path);
}
//https://learnopengl.com/Advanced-Lighting/Normal-Mapping
void Mesh::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {

	for (</span>unsigned int i=0; i&lt;vertices.size()<span class='highlight-red'>; i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = </span>1.0f/<span class='highlight-red'>(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	</span>for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	{
		glm::vec3 &amp; n = normals[i];
		glm::vec3 &amp; t = tangents[i];
		glm::vec3 &amp; b = bitangents[i];
		
		// Gram-Schmidt orthogonalize
		t = glm::normalize(t - n * glm::dot(n, t));
		
		// Calculate handedness
		if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
			t = t * -1.0f;
		}

	}
}
void Mesh::setTextureGroup(TextureGroup *textureGroup)
{
    colorTexture = textureGroup-&gt;getTexture(TextureType::DIFFUSE);
    normalTexture = textureGroup-&gt;getTexture(TextureType::NORMAL);
}
bool Mesh::loadOBJ(
    const char *<span class='highlight-red'>path,
    std::vector&lt;glm::vec3&gt; &amp;out_vertices,
    std::vector&lt;glm::vec2&gt; &amp;out_uvs,
    std::vector&lt;glm::vec3&gt; &amp;out_normals)
{
    </span>printf(&#34;Loading OBJ file %s...\n&#34;, path);

	std::vector&lt;unsigned int&gt; vertexIndices, uvIndices, normalIndices;
	std::vector&lt;glm::vec3&gt; temp_vertices; 
	std::vector&lt;glm::vec2&gt; temp_uvs;
	std::vector&lt;glm::vec3&gt; temp_normals;


	FILE * file = fopen(path, &#34;r&#34;);
	if( file == NULL ){
		printf(&#34;Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\n&#34;);
		getchar();
		return false;
	}

	while( 1 ){

		char lineHeader[128];
		// read the first word of the line
		int res = fscanf(file, &#34;%s&#34;, lineHeader);
		if (res == EOF)
			break; // EOF = End Of File. Quit the loop.

		// else : parse lineHeader
		
		if ( strcmp( lineHeader, &#34;v&#34; ) == 0 ){
			glm::vec3 vertex;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;vertex.x, &amp;vertex.y, &amp;vertex.z );
			temp_vertices.push_back(vertex);
		}else if ( strcmp( lineHeader, &#34;vt&#34; ) == 0 ){
			glm::vec2 uv;
			fscanf(file, &#34;%f %f\n&#34;, &amp;uv.x, &amp;uv.y );
			// uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders.
            temp_uvs.push_back(uv);
		}else if ( strcmp( lineHeader, &#34;vn&#34; ) == 0 ){
			glm::vec3 normal;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;normal.x, &amp;normal.y, &amp;normal.z );
			temp_normals.push_back(normal);
		}else if ( strcmp( lineHeader, &#34;f&#34; ) == 0 ){
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];
			int matches = fscanf(file, &#34;%d/%d/%d %d/%d/%d %d/%d/%d\n&#34;, &amp;vertexIndex[0], &amp;uvIndex[0], &amp;normalIndex[0], &amp;vertexIndex[1], &amp;uvIndex[1], &amp;normalIndex[1], &amp;vertexIndex[2], &amp;uvIndex[2], &amp;normalIndex[2] );
			if (matches != 9){
				printf(&#34;File can&#39;t be read by our simple parser :-( Try exporting with other options\n&#34;);
				fclose(file);
				return false;
			}
			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices    .push_back(uvIndex[0]);
			uvIndices    .push_back(uvIndex[1]);
			uvIndices    .push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}else{
			// Probably a comment, eat up the rest of the line
			char stupidBuffer[1000];
			fgets(stupidBuffer, 1000, file);
		}

	}

	// For each vertex of each triangle
	for( unsigned int i=0; i&lt;vertexIndices.size(); i++ ){

		// Get the indices of its attributes
		unsigned int vertexIndex = vertexIndices[i];
		unsigned int uvIndex = uvIndices[i];
		unsigned int normalIndex = normalIndices[i];
		
		// Get the attributes thanks to the index
		glm::vec3 vertex = temp_vertices[ vertexIndex-1 ];
		glm::vec2 uv = temp_uvs[ uvIndex-1 ];
		glm::vec3 normal = temp_normals[ normalIndex-1 ]<span class='highlight-red'>;
		
		// Put the attributes in buffers
		out_vertices.push_back(vertex);
		out_uvs     .push_back(uv);
		out_normals .push_back(normal);
	
	}

	//print out the vertices
    std::cout </span>&lt;&lt; &#34;Vertices: &#34; &lt;&lt; std::endl;
    for(auto v : out_vertices)
    {
        <span class='highlight-red'>std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std</span>::endl;
    }
    std::cout &lt;&lt; &#34;UVs: &#34; &lt;&lt; std::endl;
    for(auto v : out_uvs)
    {
        <span class='highlight-red'>std::cout &lt;&lt; &#34;glm::vec2(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;),&#34; &lt;&lt; std</span>::endl;
    }
    std::cout &lt;&lt; &#34;Normals: &#34; &lt;&lt; std::endl;
    for(auto v : out_normals)
    {
        <span class='highlight-red'>std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std</span>::endl;
    }

	fclose(file);
	return true;
}
void Mesh::loadMesh(std::string path) {
    //if the path is an obj
    if(path.find(&#34;.obj&#34;) != std::string::npos)
    {
        if(!loadOBJ(path.c_str(), vertices, uvs, normals))
        {
            SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
            return;
        }

    }
    else
    {
        SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
        return;
    }
    //if vertices uv and normals are not empty
    if(vertices.size() &lt; 1 || uvs.size() &lt; 1 || normals.size() &lt; 1)
    {
        SDL_Log(&#34;Error: Vertices empty %s\n&#34;, path.c_str());
        return;
    }
    //compute the tangent and bitangen
    setupMesh(vertices, uvs, normals);


}

void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals) {
    <span class='highlight-red'>this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}


void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; </span>vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    <span class='highlight-red'>glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLubyte</span>), &amp;indices[0], GL_STATIC_DRAW);
}
void Mesh::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}
Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)
{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals);
}

Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals, tangents, bitangents, indices);
<span class='highlight-red'>}

void Mesh::draw()
{
    glBindVertexArray(VAO);
    //how to call the Skybox setup function from here
    setupDraw();
    glDrawArrays(GL_TRIANGLES, 0, vertices</span>.size()<span class='highlight-red'>);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}

</span>void Mesh::draw_indexed()
{
    shader-&gt;use();
    // shader-&gt;setMat4(&#34;projection&#34;, projection);
    // shader-&gt;setMat4(&#34;view&#34;, view);
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_BYTE, (void*)0<span class='highlight-red'>);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
</span>}

Mesh::Mesh()
{
    model = glm::mat4(1.0f);
}

Mesh::~Mesh()
{
    glDeleteBuffers(1, &amp;vertexBuffer);
    glDeleteBuffers(1, &amp;normalBuffer);
    glDeleteBuffers(1, &amp;uvBuffer);
    glDeleteBuffers(1, &amp;tangentBuffer);
    glDeleteBuffers(1, &amp;bitangentBuffer);
    glDeleteVertexArrays(1, &amp;VAO);
}</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Cylinder.h&#34;

Cylinder::Cylinder(float len, float wid): Mesh()
{

    int slizeSize = 30;
    int numSlices = 360 / slizeSize;
    float high = len;
    float radius = wid;

    std::vector&lt;float&gt; sines, cosines;
    for(int th = 0; th &lt;= 360; th += slizeSize)
    {
        sines.push_back(Sin(th));
        cosines.push_back(Cos(th));
    }

    //calculate the position
    std::vector&lt;glm::vec3&gt; vertices;
    std::vector&lt;glm::vec2&gt; positions;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        positions.push_back(glm::vec2(radius * cosines[i], radius * sines[i]));
    }

    //side vertices
    for(int i = 0; i &lt;= numSlices; i++)
    {
        glm::vec3 top = glm::vec3(positions[i].x, high, positions[i].y);
        glm::vec3 bottom = glm::vec3(positions[i].x, 0, positions[i].y);
        vertices.push_back(top);
        vertices.push_back(bottom);
    }

        glm::vec3 top = glm::vec3(0, high, 0);
        vertices.push_back(top);
        for(int i = 0; i &lt;= numSlices; i++)
        {
            vertices.push_back(glm::vec3(positions[i].x, high, positions[i].y));
        }

        glm::vec3 bottom = glm::vec3(0, 0, 0);
        vertices.push_back(bottom);

        for(int i = 0; i &lt;= numSlices; i++)
        {
            vertices.push_back(glm::vec3(positions[i].x, 0, positions[i].y));
        }

    //texture coords
    std::vector&lt;glm::vec2&gt; uvs;
    float reps = 3;
    float uvSliceStep = reps / numSlices;

    float currentUVCoord = 0;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(currentUVCoord, 1));
        uvs.push_back(glm::vec2(currentUVCoord, 0));
        currentUVCoord += uvSliceStep;
    }

    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 + cosines[i] * 0.5));
    }
    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 - cosines[i] * 0.5));
    }

    //normals
    std::vector&lt;glm::vec3&gt; normals;
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(cosines[i], 0, sines[i]));
    }

    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, 1, 0));
    }
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, -1, 0));
    }
    
    numSideVertices = (numSlices+1) * 2;
    numCapVertices = numSlices + 2;
    numVertices = numSideVertices + numCapVertices*2;

    // setupMesh(vertices, uvs, normals);
        <span class='highlight-green'>this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}
void Cylinder::computeTangentBasis(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) {
    //depending on the vertices we will have to change because triangle fan reuses vertices
	for (</span>int i=0; i&lt;=numSideVertices<span class='highlight-green'>; i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = </span><span class='highlight-green'>(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Cylinder Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
		#endif
        // Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);

	}
    glm::vec3 </span>top = vertices[numSideVertices];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + i + 1];
        glm::vec3 &amp; v2 = top;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices<span class='highlight-green'>];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = </span><span class='highlight-green'>(uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
    glm::vec3 </span>bottom = vertices[numSideVertices + numCapVertices/2];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + numCapVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + numCapVertices + i + 1];
        glm::vec3 &amp; v2 = bottom;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + numCapVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + numCapVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices + numCapVertices<span class='highlight-green'>];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = </span><span class='highlight-green'>(uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
</span><span class='highlight-green'>}
void Cylinder::draw() {
    glBindVertexArray(VAO);
    setupDraw();

    glDrawArrays(GL_TRIANGLE_STRIP, 0, numSideVertices</span>);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices, numCapVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices + numCapVertices, numCapVertices<span class='highlight-green'>);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}</span></code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Sphere.h</i> (<b>36.26%</b>)<br>
    Reference file: <i>Mesh.cpp</i> (<b>3.11%</b>)<br>
    Token overlap: 107<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-18" aria-expanded="false" aria-controls="collapse-18">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-18">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef SPHERE_H
#define SPHERE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Sphere : public Mesh
{
public:
    Sphere(float radius, int slicesVertical, int slicesHorizontal);
    void draw();
    void computeTangentBasis<span class='highlight-red'>(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;

private:

    std::vector&lt;int&gt; indices;
    GLuint indexBuffer;

    float radius;
    int numSlices;
    int numStacks;
    int numVertices;
    int numIndices;
    GLuint numPoleIndices;
    GLuint numSideIndices;

    GLuint northPoleOffset;
    GLuint sideOffset;
    GLuint southPoleOffset;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Mesh.h&#34;

Mesh::Mesh(std::string path)
{
    model = glm::mat4(1.0f);
    loadMesh(path);
}
//https://learnopengl.com/Advanced-Lighting/Normal-Mapping
void Mesh::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{

	for (unsigned int i=0; i&lt;vertices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	{
		glm::vec3 &amp; n = normals[i];
		glm::vec3 &amp; t = tangents[i];
		glm::vec3 &amp; b = bitangents[i];
		
		// Gram-Schmidt orthogonalize
		t = glm::normalize(t - n * glm::dot(n, t));
		
		// Calculate handedness
		if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
			t = t * -1.0f;
		}

	}
}
void Mesh::setTextureGroup(TextureGroup *textureGroup)
{
    colorTexture = textureGroup-&gt;getTexture(TextureType::DIFFUSE);
    normalTexture = textureGroup-&gt;getTexture(TextureType::NORMAL);
}
bool Mesh::loadOBJ(
    const char *<span class='highlight-green'>path,
    std::vector&lt;glm::vec3&gt; &amp;out_vertices,
    std::vector&lt;glm::vec2&gt; &amp;out_uvs,
    std::vector&lt;glm::vec3&gt; &amp;out_normals)
</span>{
    printf(&#34;Loading OBJ file %s...\n&#34;, path);

	std::vector&lt;unsigned int&gt; vertexIndices, uvIndices, normalIndices;
	std::vector&lt;glm::vec3&gt; temp_vertices; 
	std::vector&lt;glm::vec2&gt; temp_uvs;
	std::vector&lt;glm::vec3&gt; temp_normals;


	FILE * file = fopen(path, &#34;r&#34;);
	if( file == NULL ){
		printf(&#34;Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\n&#34;);
		getchar();
		return false;
	}

	while( 1 ){

		char lineHeader[128];
		// read the first word of the line
		int res = fscanf(file, &#34;%s&#34;, lineHeader);
		if (res == EOF)
			break; // EOF = End Of File. Quit the loop.

		// else : parse lineHeader
		
		if ( strcmp( lineHeader, &#34;v&#34; ) == 0 ){
			glm::vec3 vertex;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;vertex.x, &amp;vertex.y, &amp;vertex.z );
			temp_vertices.push_back(vertex);
		}else if ( strcmp( lineHeader, &#34;vt&#34; ) == 0 ){
			glm::vec2 uv;
			fscanf(file, &#34;%f %f\n&#34;, &amp;uv.x, &amp;uv.y );
			// uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders.
            temp_uvs.push_back(uv);
		}else if ( strcmp( lineHeader, &#34;vn&#34; ) == 0 ){
			glm::vec3 normal;
			fscanf(file, &#34;%f %f %f\n&#34;, &amp;normal.x, &amp;normal.y, &amp;normal.z );
			temp_normals.push_back(normal);
		}else if ( strcmp( lineHeader, &#34;f&#34; ) == 0 ){
			std::string vertex1, vertex2, vertex3;
			unsigned int vertexIndex[3], uvIndex[3], normalIndex[3];
			int matches = fscanf(file, &#34;%d/%d/%d %d/%d/%d %d/%d/%d\n&#34;, &amp;vertexIndex[0], &amp;uvIndex[0], &amp;normalIndex[0], &amp;vertexIndex[1], &amp;uvIndex[1], &amp;normalIndex[1], &amp;vertexIndex[2], &amp;uvIndex[2], &amp;normalIndex[2] );
			if (matches != 9){
				printf(&#34;File can&#39;t be read by our simple parser :-( Try exporting with other options\n&#34;);
				fclose(file);
				return false;
			}
			vertexIndices.push_back(vertexIndex[0]);
			vertexIndices.push_back(vertexIndex[1]);
			vertexIndices.push_back(vertexIndex[2]);
			uvIndices    .push_back(uvIndex[0]);
			uvIndices    .push_back(uvIndex[1]);
			uvIndices    .push_back(uvIndex[2]);
			normalIndices.push_back(normalIndex[0]);
			normalIndices.push_back(normalIndex[1]);
			normalIndices.push_back(normalIndex[2]);
		}else{
			// Probably a comment, eat up the rest of the line
			char stupidBuffer[1000];
			fgets(stupidBuffer, 1000, file);
		}

	}

	// For each vertex of each triangle
	for( unsigned int i=0; i&lt;vertexIndices.size(); i++ ){

		// Get the indices of its attributes
		unsigned int vertexIndex = vertexIndices[i];
		unsigned int uvIndex = uvIndices[i];
		unsigned int normalIndex = normalIndices[i];
		
		// Get the attributes thanks to the index
		glm::vec3 vertex = temp_vertices[ vertexIndex-1 ];
		glm::vec2 uv = temp_uvs[ uvIndex-1 ];
		glm::vec3 normal = temp_normals[ normalIndex-1 ];
		
		// Put the attributes in buffers
		out_vertices.push_back(vertex);
		out_uvs     .push_back(uv);
		out_normals .push_back(normal);
	
	}

	//print out the vertices
    std::cout &lt;&lt; &#34;Vertices: &#34; &lt;&lt; std::endl;
    for(auto v : out_vertices)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;UVs: &#34; &lt;&lt; std::endl;
    for(auto v : out_uvs)
    {
        std::cout &lt;&lt; &#34;glm::vec2(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &#34;Normals: &#34; &lt;&lt; std::endl;
    for(auto v : out_normals)
    {
        std::cout &lt;&lt; &#34;glm::vec3(&#34; &lt;&lt; v.x &lt;&lt; &#34;, &#34; &lt;&lt; v.y &lt;&lt; &#34;, &#34; &lt;&lt; v.z &lt;&lt; &#34;),&#34; &lt;&lt; std::endl;
    }

	fclose(file);
	return true;
}
void Mesh::loadMesh(std::string path) {
    //if the path is an obj
    if(path.find(&#34;.obj&#34;) != std::string::npos)
    {
        if(!loadOBJ(path.c_str(), vertices, uvs, normals))
        {
            SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
            return;
        }

    }
    else
    {
        SDL_Log(&#34;Error: Could not load obj file %s\n&#34;, path.c_str());
        return;
    }
    //if vertices uv and normals are not empty
    if(vertices.size() &lt; 1 || uvs.size() &lt; 1 || normals.size() &lt; 1)
    {
        SDL_Log(&#34;Error: Vertices empty %s\n&#34;, path.c_str());
        return;
    }
    //compute the tangent and bitangen
    setupMesh(vertices, uvs, normals);


}

void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals) {
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}


void Mesh::setupMesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;elementBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLubyte), &amp;indices[0], GL_STATIC_DRAW);
}
void Mesh::setupDraw()
{
    shader-&gt;use();
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );
}
Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals)
{
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals);
}

Mesh::Mesh(std::vector&lt;glm::vec3&gt; vertices, std::vector&lt;glm::vec2&gt; uvs, std::vector&lt;glm::vec3&gt; normals, std::vector&lt;glm::vec3&gt; tangents, std::vector&lt;glm::vec3&gt; bitangents, std::vector&lt;GLubyte&gt; indices) {
    model = glm::mat4(1.0f);
    setupMesh(vertices, uvs, normals, tangents, bitangents, indices);
}

void Mesh::draw()
{
    glBindVertexArray(VAO);
    //how to call the Skybox setup function from here
    setupDraw();
    glDrawArrays(GL_TRIANGLES, 0, vertices.size());
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}

void Mesh::draw_indexed()
{
    shader-&gt;use();
    // shader-&gt;setMat4(&#34;projection&#34;, projection);
    // shader-&gt;setMat4(&#34;view&#34;, view);
    shader-&gt;setMat4(&#34;model&#34;, model);

    glActiveTexture(GL_TEXTURE0);
    colorTexture-&gt;bind();
    shader-&gt;setInt(&#34;colorTexture&#34;, 0);

    glActiveTexture(GL_TEXTURE1);
    normalTexture-&gt;bind();
    shader-&gt;setInt(&#34;normalTexture&#34;, 1);

    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glVertexAttribPointer(
        0,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glVertexAttribPointer(
        1,                  // attribute
        2,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glVertexAttribPointer(
        2,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(3);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glVertexAttribPointer(
        3,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glEnableVertexAttribArray(4);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glVertexAttribPointer(
        4,                  // attribute
        3,                  // size
        GL_FLOAT,           // type
        GL_FALSE,           // normalized?
        0,                  // stride
        (void*)0            // array buffer offset
    );

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elementBuffer);
    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_BYTE, (void*)0);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
}

Mesh::Mesh()
{
    model = glm::mat4(1.0f);
}

Mesh::~Mesh()
{
    glDeleteBuffers(1, &amp;vertexBuffer);
    glDeleteBuffers(1, &amp;normalBuffer);
    glDeleteBuffers(1, &amp;uvBuffer);
    glDeleteBuffers(1, &amp;tangentBuffer);
    glDeleteBuffers(1, &amp;bitangentBuffer);
    glDeleteVertexArrays(1, &amp;VAO);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Sphere.h</i> (<b>36.26%</b>)<br>
    Reference file: <i>objects/Cylinder.cpp</i> (<b>3.00%</b>)<br>
    Token overlap: 66<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-19" aria-expanded="false" aria-controls="collapse-19">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-19">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef SPHERE_H
#define SPHERE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Sphere : public Mesh
{
public:
    Sphere(float radius, int slicesVertical, int slicesHorizontal);
    void draw();
    void computeTangentBasis<span class='highlight-red'>(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;

private:

    std::vector&lt;int&gt; indices;
    GLuint indexBuffer;

    float radius;
    int numSlices;
    int numStacks;
    int numVertices;
    int numIndices;
    GLuint numPoleIndices;
    GLuint numSideIndices;

    GLuint northPoleOffset;
    GLuint sideOffset;
    GLuint southPoleOffset;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Cylinder.h&#34;

Cylinder::Cylinder(float len, float wid): Mesh()
{

    int slizeSize = 30;
    int numSlices = 360 / slizeSize;
    float high = len;
    float radius = wid;

    std::vector&lt;float&gt; sines, cosines;
    for(int th = 0; th &lt;= 360; th += slizeSize)
    {
        sines.push_back(Sin(th));
        cosines.push_back(Cos(th));
    }

    //calculate the position
    std::vector&lt;glm::vec3&gt; vertices;
    std::vector&lt;glm::vec2&gt; positions;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        positions.push_back(glm::vec2(radius * cosines[i], radius * sines[i]));
    }

    //side vertices
    for(int i = 0; i &lt;= numSlices; i++)
    {
        glm::vec3 top = glm::vec3(positions[i].x, high, positions[i].y);
        glm::vec3 bottom = glm::vec3(positions[i].x, 0, positions[i].y);
        vertices.push_back(top);
        vertices.push_back(bottom);
    }

        glm::vec3 top = glm::vec3(0, high, 0);
        vertices.push_back(top);
        for(int i = 0; i &lt;= numSlices; i++)
        {
            vertices.push_back(glm::vec3(positions[i].x, high, positions[i].y));
        }

        glm::vec3 bottom = glm::vec3(0, 0, 0);
        vertices.push_back(bottom);

        for(int i = 0; i &lt;= numSlices; i++)
        {
            vertices.push_back(glm::vec3(positions[i].x, 0, positions[i].y));
        }

    //texture coords
    std::vector&lt;glm::vec2&gt; uvs;
    float reps = 3;
    float uvSliceStep = reps / numSlices;

    float currentUVCoord = 0;

    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(currentUVCoord, 1));
        uvs.push_back(glm::vec2(currentUVCoord, 0));
        currentUVCoord += uvSliceStep;
    }

    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 + cosines[i] * 0.5));
    }
    uvs.push_back(glm::vec2(0.5, 0.5));
    for(int i = 0; i &lt;= numSlices; i++)
    {
        uvs.push_back(glm::vec2(0.5 + sines[i] * 0.5, 0.5 - cosines[i] * 0.5));
    }

    //normals
    std::vector&lt;glm::vec3&gt; normals;
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(cosines[i], 0, sines[i]));
    }

    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, 1, 0));
    }
    for(int i = 0; i &lt;= numSlices; i++)
    {
        normals.push_back(glm::vec3(0, -1, 0));
    }
    
    numSideVertices = (numSlices+1) * 2;
    numCapVertices = numSlices + 2;
    numVertices = numSideVertices + numCapVertices*2;

    // setupMesh(vertices, uvs, normals);
        this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    std::vector&lt;unsigned short&gt; indices;
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);
}
void Cylinder::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{
    //depending on the vertices we will have to change because triangle fan reuses vertices
	for (int i=0; i&lt;=numSideVertices; i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = (uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Cylinder Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
		#endif
        // Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);

	}
    glm::vec3 top = vertices[numSideVertices];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + i + 1];
        glm::vec3 &amp; v2 = top;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = (uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
    glm::vec3 bottom = vertices[numSideVertices + numCapVertices/2];
    for(int i =0; i&lt;=numCapVertices/2; i++)
    {
        glm::vec3 &amp; v0 = vertices[numSideVertices + numCapVertices + i];
        glm::vec3 &amp; v1 = vertices[numSideVertices + numCapVertices + i + 1];
        glm::vec3 &amp; v2 = bottom;

        // Shortcuts for UVs
        glm::vec2 &amp; uv0 = uvs[numSideVertices + numCapVertices + i];
        glm::vec2 &amp; uv1 = uvs[numSideVertices + numCapVertices + i + 1];
        glm::vec2 &amp; uv2 = uvs[numSideVertices + numCapVertices];

        // Edges of the triangle : postion delta
        glm::vec3 deltaPos1 = v1-v0;
        glm::vec3 deltaPos2 = v2-v0;

        // UV delta
        glm::vec2 deltaUV1 = uv1-uv0;
        glm::vec2 deltaUV2 = uv2-uv0;

        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
        float r = (uvDeterminant);
        glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
        glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;

        tangents.push_back(tangent);
        tangents.push_back(tangent);
        tangents.push_back(tangent);

        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
        bitangents.push_back(bitangent);
    }
}
void Cylinder::draw() {
    glBindVertexArray(VAO);
    setupDraw();

    glDrawArrays(GL_TRIANGLE_STRIP, 0, numSideVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices, numCapVertices);

    glDrawArrays(GL_TRIANGLE_FAN, numSideVertices + numCapVertices, numCapVertices);
    

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);
}</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  <tr>
  <td style="text-align: center;">
  <p>
    Test file: <i>objects/Sphere.h</i> (<b>36.26%</b>)<br>
    Reference file: <i>objects/Sphere.cpp</i> (<b>3.17%</b>)<br>
    Token overlap: 66<br><br>
    <button class="btn btn-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-20" aria-expanded="false" aria-controls="collapse-20">
      View matched code
    </button>
  </p>
  <div class="collapse" id="collapse-20">
    <div class="card card-body">
      <div class="row">
        <div class="col code-display">
          <pre><code>#ifndef SPHERE_H
#define SPHERE_H

#include &#34;../lib.h&#34;
#include &#34;../Mesh.h&#34;

class Sphere : public Mesh
{
public:
    Sphere(float radius, int slicesVertical, int slicesHorizontal);
    void draw();
    void computeTangentBasis<span class='highlight-red'>(
        // inputs
        std::vector&lt;glm::vec3&gt; &amp; vertices,
        std::vector&lt;glm::vec2&gt; &amp; uvs,
        std::vector&lt;glm::vec3&gt; &amp; normals,
        // outputs
        std::vector&lt;glm::vec3&gt; &amp; tangents,
        std::vector&lt;glm::vec3&gt; &amp; bitangents)</span>;

private:

    std::vector&lt;int&gt; indices;
    GLuint indexBuffer;

    float radius;
    int numSlices;
    int numStacks;
    int numVertices;
    int numIndices;
    GLuint numPoleIndices;
    GLuint numSideIndices;

    GLuint northPoleOffset;
    GLuint sideOffset;
    GLuint southPoleOffset;
};
#endif // CYLINDER_H</code></pre>
        </div>
        <div class="col code-display">
          <pre><code>#include &#34;Sphere.h&#34;

//adapted from https://songho.ca/opengl/gl_sphere.html
Sphere::Sphere(float radius, int numStacks, int numSlices): Mesh()
{
    // loadOBJ(&#34;sphere.obj&#34;, vertices, uvs, normals);
    this-&gt;radius = radius;
    this-&gt;numSlices = numSlices;
    this-&gt;numStacks = numStacks;
    numVertices = (numStacks + 1) * (numSlices + 1);
    
    float x;
    float y;
    float z;
    float xy;

    float nx;
    float ny;
    float nz;
    float lengthInv = 1.0f / radius;

    float s;
    float t;

    float sectorStep = 2 * M_PI / numSlices;
    float stackStep = M_PI / numStacks;

    for(int i=0; i&lt;= numStacks; i++)
    {
        float stackAngle = M_PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * sinf(stackAngle);

        for(int j=0; j&lt;=numSlices; j++)
        {
            float sectorAngle = j * sectorStep;

            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);

            vertices.push_back(glm::vec3(x, y, z));
            nx = x * lengthInv;
            ny = y * lengthInv;
            nz = z * lengthInv;
            normals.push_back(glm::vec3(nx, ny, nz));

            s = (float)j / numSlices;
            t = (float)i / numStacks;
            uvs.push_back(glm::vec2(s, t));
        }
    }

    unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }

            if(i != (numStacks - 1))
            {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }

        }
    }
    // setupMesh(vertices, uvs, normals);
    this-&gt;vertices = vertices;
    this-&gt;uvs = uvs;
    this-&gt;normals = normals;
    tangents.resize(vertices.size());
    bitangents.resize(vertices.size());
    Sphere::computeTangentBasis(vertices, uvs, normals, tangents, bitangents);
    glGenVertexArrays(1, &amp;VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &amp;vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &amp;vertices[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;uvBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, uvBuffer);
    glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(glm::vec2), &amp;uvs[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;normalBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, normalBuffer);
    glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(glm::vec3), &amp;normals[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;tangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, tangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(glm::vec3), &amp;tangents[0], GL_STATIC_DRAW);

    glGenBuffers(1, &amp;bitangentBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, bitangentBuffer);
    glBufferData(GL_ARRAY_BUFFER, bitangents.size() * sizeof(glm::vec3), &amp;bitangents[0], GL_STATIC_DRAW);

    // glBindVertexArray(VAO);
    glGenBuffers(1, &amp;indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;indices[0], GL_STATIC_DRAW);
}

void Sphere::draw()
{
    //print radius
    glBindVertexArray(VAO);
    setupDraw();
    //set the index buffer
    int temp_offset = 0;
    glDrawElements(GL_TRIANGLES, indices.size()-temp_offset, GL_UNSIGNED_INT, (void*)(temp_offset* sizeof(GLuint)));

    //draw normals tangents and bitangents for debugging
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    // glDrawArrays(GL_LINES, 0, vertices.size());
    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);
    glDisableVertexAttribArray(2);
    glDisableVertexAttribArray(3);
    glDisableVertexAttribArray(4);
    glBindVertexArray(0);

}

void Sphere::computeTangentBasis<span class='highlight-green'>(
	// inputs
	std::vector&lt;glm::vec3&gt; &amp; vertices,
	std::vector&lt;glm::vec2&gt; &amp; uvs,
	std::vector&lt;glm::vec3&gt; &amp; normals,
	// outputs
	std::vector&lt;glm::vec3&gt; &amp; tangents,
	std::vector&lt;glm::vec3&gt; &amp; bitangents
) </span>{

    unsigned int k1, k2;
    for(int i=0; i&lt;numStacks; i++)
    {
        k1 = i * (numSlices + 1);
        k2 = k1 + numSlices + 1;

        for(int j=0; j&lt;numSlices; j++, k1++, k2++)
        {
            if(i != 0)
            {
                // indices.push_back(k1);
                // indices.push_back(k2);
                // indices.push_back(k1 + 1);
                		// Shortcuts for vertices
                glm::vec3 &amp; v0 = vertices[k1];
                glm::vec3 &amp; v1 = vertices[k2];
                glm::vec3 &amp; v2 = vertices[k1+1];

                // Shortcuts for UVs
                // glm::vec2 &amp; uv0 = uvs[i+0];
                // glm::vec2 &amp; uv1 = uvs[i+1];
                // glm::vec2 &amp; uv2 = uvs[i+2];
                glm::vec2 &amp; uv0 = uvs[k1];
                glm::vec2 &amp; uv1 = uvs[k2];
                glm::vec2 &amp; uv2 = uvs[k1+1];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = (uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);

            }

            if(i != (numStacks - 1))
            {
                // indices.push_back(k1 + 1);
                // indices.push_back(k2);
                // indices.push_back(k2 + 1);
                glm::vec3 &amp; v0 = vertices[k1+1];
                glm::vec3 &amp; v1 = vertices[k2];
                glm::vec3 &amp; v2 = vertices[k2+1];

                // Shortcuts for UVs
                glm::vec2 &amp; uv0 = uvs[i+0];
                glm::vec2 &amp; uv1 = uvs[i+1];
                glm::vec2 &amp; uv2 = uvs[i+2];

                // Edges of the triangle : postion delta
                glm::vec3 deltaPos1 = v1-v0;
                glm::vec3 deltaPos2 = v2-v0;

                // UV delta
                glm::vec2 deltaUV1 = uv1-uv0;
                glm::vec2 deltaUV2 = uv2-uv0;


                float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
                float r = 1.0f/(uvDeterminant);
                glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
                glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
                #ifdef DEBUG
                std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
                #endif
                // Set the same tangent for all three vertices of the triangle.
                tangents.push_back(tangent);
                tangents.push_back(tangent);
                tangents.push_back(tangent);

                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
                bitangents.push_back(bitangent);
            }

        }
    }

	for (unsigned int i=0; i&lt;indices.size(); i+=3 ){

		// Shortcuts for vertices
		glm::vec3 &amp; v0 = vertices[i+0];
		glm::vec3 &amp; v1 = vertices[i+1];
		glm::vec3 &amp; v2 = vertices[i+2];

		// Shortcuts for UVs
		glm::vec2 &amp; uv0 = uvs[i+0];
		glm::vec2 &amp; uv1 = uvs[i+1];
		glm::vec2 &amp; uv2 = uvs[i+2];

		// Edges of the triangle : postion delta
		glm::vec3 deltaPos1 = v1-v0;
		glm::vec3 deltaPos2 = v2-v0;

		// UV delta
		glm::vec2 deltaUV1 = uv1-uv0;
		glm::vec2 deltaUV2 = uv2-uv0;


        float uvDeterminant = deltaUV1.x * deltaUV2.y - deltaUV1.y * deltaUV2.x;
		float r = 1.0f/(uvDeterminant);
		glm::vec3 tangent = (deltaPos1 * deltaUV2.y   - deltaPos2 * deltaUV1.y)*r;
		glm::vec3 bitangent = (deltaPos2 * deltaUV1.x   - deltaPos1 * deltaUV2.x)*r;
        #ifdef DEBUG
        std::cout &lt;&lt; &#34;Tangent: &#34; &lt;&lt; tangent.x &lt;&lt; &#34; &#34; &lt;&lt; tangent.y &lt;&lt; &#34; &#34; &lt;&lt; tangent.z &lt;&lt; std::endl;
        #endif
		// Set the same tangent for all three vertices of the triangle.
		tangents.push_back(tangent);
		tangents.push_back(tangent);
		tangents.push_back(tangent);

		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);
		bitangents.push_back(bitangent);



	}

	// See &#34;Going Further&#34;
	// for (unsigned int i=0; i&lt;vertices.size(); i+=1 )
	// {
	// 	glm::vec3 &amp; n = normals[i];
	// 	glm::vec3 &amp; t = tangents[i];
	// 	glm::vec3 &amp; b = bitangents[i];
		
	// 	// Gram-Schmidt orthogonalize
	// 	t = glm::normalize(t - n * glm::dot(n, t));
		
	// 	// Calculate handedness
	// 	if (glm::dot(glm::cross(n, t), b) &lt; 0.0f){
	// 		t = t * -1.0f;
	// 	}

	// }
}
</code></pre>
        </div>
      </div>
    </div>
  </div>
  </td>
  </tr>
  
  </tbody>
  </table>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-kQtW33rZJAHjgefvhyyzcGF3C5TFyBQBA13V1RKPf4uH+bwyzQxZ6CmMZHmNBEfJ" crossorigin="anonymous"></script>
</body>